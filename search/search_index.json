{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"xcube-resampling","text":"<p>xcube-resampling provides efficient algorithms for transforming datasets into  different spatial grid mappings. It is designed for geospatial workflows that need  flexible resampling and reprojection.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>Affine resampling \u2013 simple resampling using affine transformations  </li> <li>Reprojection \u2013 convert datasets between different coordinate reference systems (CRS)  </li> <li>Rectification \u2013 transform irregular grids into regular, well-structured grids  </li> </ul> <p>All methods work seamlessly with chunked (lazily loaded) xarray.Datasets and are powered by Dask for scalable, out-of-core computation.</p>"},{"location":"#lightweight-independent","title":"\u26a1 Lightweight &amp; Independent","text":"<p>The package is independent of the core xcube framework and has minimal dependencies: <code>affine, dask, dask-image, numba, numpy, pyproj, xarray, zarr</code>.</p>"},{"location":"#overview","title":"Overview","text":"<p>The resampling methods are built around the <code>GridMapping</code> class, which represents a spatial grid mapping and contains all necessary information for resampling.  </p> <p>A <code>GridMapping</code> is required for affine transformation and reprojection, and optional for rectification. If omitted for rectification, a simple rectification will be performed while staying in the same CRS.</p>"},{"location":"#resample_in_space-the-gateway-to-xcube-resampling","title":"<code>resample_in_space</code> \u2014 the gateway to xcube-resampling","text":"<p>The central function in this package is <code>resample_in_space</code>, which integrates all three algorithms and automatically selects the appropriate one based on the criteria below.</p> Algorithm Function Selection Criteria Affine Transformation <code>affine_transform_dataset</code> Source and target grids are both regular and share the same CRS. Reprojection <code>reproject_dataset</code> Source and target grids are both regular but have different CRS. Rectification <code>rectify_dataset</code> Source grid is irregular and contains 2D coordinates. <p>With <code>resample_in_space</code>, users do not need to worry about selecting the right algorithm\u2014the function determines and applies it automatically.</p> <p>\ud83d\udc49 For usage examples and details, see the User Guide.</p>"},{"location":"#license","title":"License","text":"<p><code>xcube-resampling</code> is open source made available under the terms and conditions of the  MIT license.</p>"},{"location":"about/","title":"About the <code>xcube-resampling</code> project","text":""},{"location":"about/#changelog","title":"Changelog","text":"<p>You can find the complete <code>xcube-resampling</code> changelog  here. </p>"},{"location":"about/#reporting","title":"Reporting","text":"<p>If you have suggestions, ideas, feature requests, or if you have identified a malfunction or error, then please  post an issue. </p>"},{"location":"about/#contributions","title":"Contributions","text":"<p>The <code>xcube-resampling</code> project welcomes contributions of any form as long as you respect our  code of conduct and follow our  contribution guide.</p> <p>If you'd like to submit code or documentation changes, we ask you to provide a  pull request (PR)  here.  For code and configuration changes, your PR must be linked to a  corresponding issue. </p>"},{"location":"about/#development","title":"Development","text":"<p>To install the <code>xcube-resampling</code> development environment into an existing Python  environment, do</p> <pre><code>pip install .[dev,doc]\n</code></pre> <p>or create a new environment using <code>conda</code> or <code>mamba</code></p> <pre><code>mamba env create \n</code></pre>"},{"location":"about/#testing-and-coverage","title":"Testing and Coverage","text":"<p><code>xcube-resampling</code> uses pytest for unit-level testing  and code coverage analysis.</p> <pre><code>pytest tests/ --cov=xcube_resampling --cov-report html\n</code></pre>"},{"location":"about/#code-style","title":"Code Style","text":"<p>The <code>xcube-resampling</code> source code is formatted and quality-controlled  using ruff:</p> <pre><code>ruff format\nruff check\n</code></pre>"},{"location":"about/#documentation","title":"Documentation","text":"<p>The <code>xcube-resampling</code> documentation is built using the  mkdocs tool.</p> <p>With repository root as current working directory:</p> <pre><code>pip install .[doc]\n\nmkdocs build\nmkdocs serve\nmkdocs gh-deploy\n</code></pre>"},{"location":"about/#license","title":"License","text":"<p><code>xcube-resampling</code> is open source made available under the terms and conditions of the  MIT license.</p>"},{"location":"api/","title":"Python API","text":""},{"location":"api/#xcube_resampling.spatial.resample_in_space","title":"<code>xcube_resampling.spatial.resample_in_space(source_ds, target_gm=None, source_gm=None, variables=None, interp_methods=None, agg_methods=None, recover_nans=False, fill_values=None, tile_size=None)</code>","text":"<p>Resample the spatial dimensions of a dataset to match a target grid mapping.</p> <p>Depending on the regularity and compatibility of the source and target grid mappings, this function will either rectify, reproject, or affine-transform the spatial dimensions of <code>source_ds</code>.</p> <p>Parameters:</p> Name Type Description Default <code>source_ds</code> <code>Dataset</code> <p>The input xarray.Dataset. Data variables must have dimensions in the following order: optional third dimension followed by the y-dimension (e.g., \"y\" or \"lat\") and the x-dimension (e.g., \"x\" or \"lon\").</p> required <code>target_gm</code> <code>GridMapping | None</code> <p>The target GridMapping to which the dataset should be resampled. Must be regular. If not provided, a default regular grid is derived from <code>source_gm</code> using <code>to_regular(tile_size)</code>.</p> <code>None</code> <code>source_gm</code> <code>GridMapping | None</code> <p>The GridMapping describing the source dataset's spatial layout. If not provided, it is inferred from <code>source_ds</code> using <code>GridMapping.from_dataset(source_ds)</code>.</p> <code>None</code> <code>variables</code> <code>str | Iterable[str] | None</code> <p>A single variable name or iterable of variable names to be resampled. If None, all data variables will be processed.</p> <code>None</code> <code>interp_methods</code> <code>InterpMethods | None</code> <p>Optional interpolation method to be used for upsampling spatial data variables. Can be a single interpolation method for all variables or a dictionary mapping variable names or dtypes to interpolation method. Supported methods include:</p> <ul> <li><code>0</code> (nearest neighbor)</li> <li><code>1</code> (linear / bilinear)</li> <li><code>\"nearest\"</code></li> <li><code>\"triangular\"</code></li> <li><code>\"bilinear\"</code></li> </ul> <p>The default is <code>0</code> for integer arrays, else <code>1</code>.</p> <code>None</code> <code>agg_methods</code> <code>AggMethods | None</code> <p>Optional aggregation methods for downsampling spatial variables. Can be a single method for all variables or a dictionary mapping variable names or dtypes to methods. Supported methods include:     \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",     \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\". Defaults to \"center\" for integer arrays, else \"mean\".</p> <code>None</code> <code>recover_nans</code> <code>RecoverNans</code> <p>Optional boolean or mapping to enable NaN recovery during upsampling (only applies when interpolation method is not nearest). Can be a single boolean or a dictionary mapping variable names or dtypes to booleans. Defaults to False.</p> <code>False</code> <code>fill_values</code> <code>FillValues | None</code> <p>Optional fill value(s) for areas outside input coverage. Can be a single value or dictionary by variable or type. If not provided, defaults based on data type are used:</p> <ul> <li>float: NaN</li> <li>uint8: 255</li> <li>uint16: 65535</li> <li>other ints: -1</li> </ul> <code>None</code> <code>tile_size</code> <code>int | tuple[int, int] | None</code> <p>Optional tile size used when generating a regular grid from an irregular source grid mapping. Only used if <code>target_gm</code> is not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>A new dataset that has been spatially resampled to match the target grid mapping.</p> Notes <ul> <li>If <code>source_gm</code> is not provided, it is inferred from <code>source_ds</code>.</li> <li>If <code>target_gm</code> is not provided, and the source is irregular, it is   derived from <code>source_gm.to_regular(tile_size=tile_size)</code>.</li> <li>If both grid mappings are regular and approximately equal, the original   dataset is returned unchanged.</li> <li>If the transformation can be represented as an affine mapping, it is   applied directly for performance.</li> <li>If the source is irregular, rectification is applied.</li> <li>Otherwise, a reprojection is performed.</li> <li>See the xcube-resampling documentation   for more details.</li> </ul> Source code in <code>xcube_resampling/spatial.py</code> <pre><code>def resample_in_space(\n    source_ds: xr.Dataset,\n    target_gm: GridMapping | None = None,\n    source_gm: GridMapping | None = None,\n    variables: str | Iterable[str] | None = None,\n    interp_methods: InterpMethods | None = None,\n    agg_methods: AggMethods | None = None,\n    recover_nans: RecoverNans = False,\n    fill_values: FillValues | None = None,\n    tile_size: int | tuple[int, int] | None = None,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Resample the spatial dimensions of a dataset to match a target grid mapping.\n\n    Depending on the regularity and compatibility of the source and target grid\n    mappings, this function will either rectify, reproject, or affine-transform the\n    spatial dimensions of `source_ds`.\n\n    Args:\n        source_ds: The input xarray.Dataset. Data variables must have dimensions\n            in the following order: optional third dimension followed by the\n            y-dimension (e.g., \"y\" or \"lat\") and the x-dimension (e.g., \"x\" or \"lon\").\n        target_gm: The target GridMapping to which the dataset should be resampled.\n            Must be regular. If not provided, a default regular grid is derived\n            from `source_gm` using `to_regular(tile_size)`.\n        source_gm: The GridMapping describing the source dataset's spatial layout.\n            If not provided, it is inferred from `source_ds` using\n            `GridMapping.from_dataset(source_ds)`.\n        variables: A single variable name or iterable of variable names to be\n            resampled. If None, all data variables will be processed.\n        interp_methods: Optional interpolation method to be used for upsampling spatial\n            data variables. Can be a single interpolation method for all variables or a\n            dictionary mapping variable names or dtypes to interpolation method.\n            Supported methods include:\n\n            - `0` (nearest neighbor)\n            - `1` (linear / bilinear)\n            - `\"nearest\"`\n            - `\"triangular\"`\n            - `\"bilinear\"`\n\n            The default is `0` for integer arrays, else `1`.\n        agg_methods: Optional aggregation methods for downsampling spatial variables.\n            Can be a single method for all variables or a dictionary mapping variable\n            names or dtypes to methods. Supported methods include:\n                \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",\n                \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\".\n            Defaults to \"center\" for integer arrays, else \"mean\".\n        recover_nans: Optional boolean or mapping to enable NaN recovery during\n            upsampling (only applies when interpolation method is not nearest).\n            Can be a single boolean or a dictionary mapping variable names or dtypes\n            to booleans. Defaults to False.\n        fill_values: Optional fill value(s) for areas outside input coverage.\n            Can be a single value or dictionary by variable or type. If not provided,\n            defaults based on data type are used:\n\n            - float: NaN\n            - uint8: 255\n            - uint16: 65535\n            - other ints: -1\n\n        tile_size: Optional tile size used when generating a regular grid from\n            an irregular source grid mapping. Only used if `target_gm` is not provided.\n\n    Returns:\n        A new dataset that has been spatially resampled to match the target grid\n            mapping.\n\n    Notes:\n        - If `source_gm` is not provided, it is inferred from `source_ds`.\n        - If `target_gm` is not provided, and the source is irregular, it is\n          derived from `source_gm.to_regular(tile_size=tile_size)`.\n        - If both grid mappings are regular and approximately equal, the original\n          dataset is returned unchanged.\n        - If the transformation can be represented as an affine mapping, it is\n          applied directly for performance.\n        - If the source is irregular, rectification is applied.\n        - Otherwise, a reprojection is performed.\n        - See the [xcube-resampling documentation](https://xcube-dev.github.io/xcube-resampling/)\n          for more details.\n    \"\"\"\n    if source_gm is None:\n        source_gm = GridMapping.from_dataset(source_ds)\n\n    if not source_gm.is_regular:\n        return rectify_dataset(\n            source_ds,\n            target_gm=target_gm,\n            source_gm=source_gm,\n            variables=variables,\n            interp_methods=interp_methods,\n            agg_methods=agg_methods,\n            recover_nans=recover_nans,\n            fill_values=fill_values,\n            tile_size=tile_size,\n        )\n    else:\n        if target_gm is None:\n            LOG.warning(\n                \"If source grid mapping is regular `target_gm` must be given. \"\n                \"Source dataset is returned.\"\n            )\n            return source_ds\n        GridMapping.assert_regular(target_gm, name=\"target_gm\")\n        if source_gm.is_close(target_gm):\n            return source_ds\n\n        if _can_apply_affine_transform(source_gm, target_gm):\n            return affine_transform_dataset(\n                source_ds,\n                target_gm,\n                source_gm=source_gm,\n                variables=variables,\n                interp_methods=interp_methods,\n                agg_methods=agg_methods,\n                recover_nans=recover_nans,\n                fill_values=fill_values,\n            )\n        else:\n            return reproject_dataset(\n                source_ds,\n                target_gm,\n                source_gm=source_gm,\n                variables=variables,\n                interp_methods=interp_methods,\n                agg_methods=agg_methods,\n                recover_nans=recover_nans,\n                fill_values=fill_values,\n            )\n</code></pre>"},{"location":"api/#xcube_resampling.affine.affine_transform_dataset","title":"<code>xcube_resampling.affine.affine_transform_dataset(source_ds, target_gm, source_gm=None, variables=None, interp_methods=None, agg_methods=None, recover_nans=False, fill_values=None)</code>","text":"<p>Apply an affine transformation to the spatial dimensions of a dataset, transforming it from the source grid mapping to the target grid mapping.</p> <p>Parameters:</p> Name Type Description Default <code>source_ds</code> <code>Dataset</code> <p>The input dataset to be transformed.</p> required <code>target_gm</code> <code>GridMapping</code> <p>The target grid mapping defining the spatial reference and output geometry.</p> required <code>source_gm</code> <code>GridMapping | None</code> <p>The grid mapping of the input dataset. If None, it is inferred from the dataset.</p> <code>None</code> <code>variables</code> <code>str | Iterable[str] | None</code> <p>Optional variable(s) to transform. If None, all variables are used.</p> <code>None</code> <code>interp_methods</code> <code>InterpMethods | None</code> <p>Optional interpolation method to be used for upsampling spatial data variables. Can be a single interpolation method for all variables or a dictionary mapping variable names or dtypes to interpolation method. Supported methods include:</p> <ul> <li><code>0</code> (nearest neighbor)</li> <li><code>1</code> (linear / bilinear)</li> <li><code>\"nearest\"</code></li> <li><code>\"bilinear\"</code></li> </ul> <p>The default is <code>0</code> for integer arrays, else <code>1</code>.</p> <code>None</code> <code>agg_methods</code> <code>AggMethods | None</code> <p>Optional aggregation methods for downsampling spatial variables. Can be a single method for all variables or a dictionary mapping variable names or dtypes to methods. Supported methods include:     \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",     \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\". Defaults to \"center\" for integer arrays, else \"mean\".</p> <code>None</code> <code>recover_nans</code> <code>RecoverNans</code> <p>Optional boolean or mapping to enable NaN recovery during upsampling (only applies when interpolation method is not nearest). Can be a single boolean or a dictionary mapping variable names or dtypes to booleans. Defaults to False.</p> <code>False</code> <code>fill_values</code> <code>FillValues | None</code> <p>Optional fill value(s) for areas outside the input bounds. Can be a single value or a dictionary mapping variable names or dtypes to fill values. If not provided, defaults are:</p> <ul> <li>float: NaN</li> <li>uint8: 255</li> <li>uint16: 65535</li> <li>other integers: -1</li> </ul> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>A new dataset resampled and aligned to the target grid mapping. Data variables without spatial dimensions are copied to the output. Data variables with only one spatial dimension are ignored.</p> Source code in <code>xcube_resampling/affine.py</code> <pre><code>def affine_transform_dataset(\n    source_ds: xr.Dataset,\n    target_gm: GridMapping,\n    source_gm: GridMapping | None = None,\n    variables: str | Iterable[str] | None = None,\n    interp_methods: InterpMethods | None = None,\n    agg_methods: AggMethods | None = None,\n    recover_nans: RecoverNans = False,\n    fill_values: FillValues | None = None,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Apply an affine transformation to the spatial dimensions of a dataset,\n    transforming it from the source grid mapping to the target grid mapping.\n\n    Args:\n        source_ds: The input dataset to be transformed.\n        target_gm: The target grid mapping defining the spatial reference and\n            output geometry.\n        source_gm: The grid mapping of the input dataset. If None, it is inferred\n            from the dataset.\n        variables: Optional variable(s) to transform. If None, all variables are used.\n        interp_methods: Optional interpolation method to be used for upsampling spatial\n            data variables. Can be a single interpolation method for all variables or a\n            dictionary mapping variable names or dtypes to interpolation method.\n            Supported methods include:\n\n            - `0` (nearest neighbor)\n            - `1` (linear / bilinear)\n            - `\"nearest\"`\n            - `\"bilinear\"`\n\n            The default is `0` for integer arrays, else `1`.\n        agg_methods: Optional aggregation methods for downsampling spatial variables.\n            Can be a single method for all variables or a dictionary mapping variable\n            names or dtypes to methods. Supported methods include:\n                \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",\n                \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\".\n            Defaults to \"center\" for integer arrays, else \"mean\".\n        recover_nans: Optional boolean or mapping to enable NaN recovery during\n            upsampling (only applies when interpolation method is not nearest).\n            Can be a single boolean or a dictionary mapping variable names or dtypes\n            to booleans. Defaults to False.\n        fill_values: Optional fill value(s) for areas outside the input bounds.\n            Can be a single value or a dictionary mapping variable names or dtypes\n            to fill values. If not provided, defaults are:\n\n            - float: NaN\n            - uint8: 255\n            - uint16: 65535\n            - other integers: -1\n\n    Returns:\n        A new dataset resampled and aligned to the target grid mapping.\n            Data variables without spatial dimensions are copied to the output.\n            Data variables with only one spatial dimension are ignored.\n    \"\"\"\n    if source_gm is None:\n        source_gm = GridMapping.from_dataset(source_ds)\n    source_ds = normalize_grid_mapping(source_ds, source_gm)\n\n    assert _can_apply_affine_transform(source_gm, target_gm), (\n        f\"Affine transformation cannot be applied to source CRS \"\n        f\"{source_gm.crs.name!r} and target CRS {target_gm.crs.name!r}\"\n    )\n\n    source_ds = _select_variables(source_ds, variables)\n\n    target_ds = resample_dataset(\n        source_ds,\n        target_gm.ij_transform_to(source_gm),\n        (source_gm.xy_dim_names[1], source_gm.xy_dim_names[0]),\n        target_gm.size,\n        target_gm.tile_size,\n        interp_methods,\n        agg_methods,\n        recover_nans,\n        fill_values,\n    )\n\n    # assign coordinates from target grid-mapping\n    x_name, y_name = target_gm.xy_var_names\n    target_ds = target_ds.assign_coords(\n        {x_name: target_gm.x_coords, y_name: target_gm.y_coords}\n    )\n\n    return target_ds\n</code></pre>"},{"location":"api/#xcube_resampling.reproject.reproject_dataset","title":"<code>xcube_resampling.reproject.reproject_dataset(source_ds, target_gm, source_gm=None, variables=None, interp_methods=None, agg_methods=None, recover_nans=False, fill_values=None)</code>","text":"<p>Reproject a dataset from one coordinate reference system (CRS) to another.</p> <p>This function transforms a dataset\u2019s 2D spatial variables to match a new CRS and grid layout defined by <code>target_gm</code>. It handles interpolation, optional downsampling, and fill values for areas outside the input bounds.</p> <p>Parameters:</p> Name Type Description Default <code>source_ds</code> <code>Dataset</code> <p>The input dataset to be reprojected.</p> required <code>target_gm</code> <code>GridMapping</code> <p>The target grid mapping that defines the spatial reference and grid layout in the target CRS.</p> required <code>source_gm</code> <code>GridMapping | None</code> <p>Optional source grid mapping of the input dataset. If not provided, it is inferred from the dataset.</p> <code>None</code> <code>variables</code> <code>str | Iterable[str] | None</code> <p>Optional variable name or list of variable names to reproject. If None, all suitable variables are processed.</p> <code>None</code> <code>interp_methods</code> <code>InterpMethods | None</code> <p>Optional interpolation method to be used for upsampling spatial data variables. Can be a single interpolation method for all variables or a dictionary mapping variable names or dtypes to interpolation method. Supported methods include:</p> <ul> <li><code>0</code> (nearest neighbor)</li> <li><code>1</code> (linear / bilinear)</li> <li><code>\"nearest\"</code></li> <li><code>\"triangular\"</code></li> <li><code>\"bilinear\"</code></li> </ul> <p>The default is <code>0</code> for integer arrays, else <code>1</code>.</p> <code>None</code> <code>agg_methods</code> <code>AggMethods | None</code> <p>Optional aggregation methods for downsampling spatial variables. Can be a single method for all variables or a dictionary mapping variable names or dtypes to methods. Supported methods include:     \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",     \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\". Defaults to \"center\" for integer arrays, else \"mean\".</p> <code>None</code> <code>recover_nans</code> <code>RecoverNans</code> <p>Optional boolean or mapping to enable NaN recovery during upsampling (only applies when interpolation method is not nearest). Can be a single boolean or a dictionary mapping variable names or dtypes to booleans. Defaults to False.</p> <code>False</code> <code>fill_values</code> <code>FillValues | None</code> <p>Optional fill value(s) to assign outside source coverage. Can be a single value or dictionary by variable or type. If not set, defaults are:</p> <ul> <li>float: NaN</li> <li>uint8: 255</li> <li>uint16: 65535</li> <li>other integers: -1</li> </ul> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>A new dataset with variables reprojected to the target CRS and grid. Variables without 2D spatial dimensions are copied as-is. 1D spatial coordinate variables are ignored in the output.</p> Source code in <code>xcube_resampling/reproject.py</code> <pre><code>def reproject_dataset(\n    source_ds: xr.Dataset,\n    target_gm: GridMapping,\n    source_gm: GridMapping | None = None,\n    variables: str | Iterable[str] | None = None,\n    interp_methods: InterpMethods | None = None,\n    agg_methods: AggMethods | None = None,\n    recover_nans: RecoverNans = False,\n    fill_values: FillValues | None = None,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Reproject a dataset from one coordinate reference system (CRS) to another.\n\n    This function transforms a dataset\u2019s 2D spatial variables to match a new CRS and\n    grid layout defined by `target_gm`. It handles interpolation, optional\n    downsampling, and fill values for areas outside the input bounds.\n\n    Args:\n        source_ds: The input dataset to be reprojected.\n        target_gm: The target grid mapping that defines the spatial reference and\n            grid layout in the target CRS.\n        source_gm: Optional source grid mapping of the input dataset. If not\n            provided, it is inferred from the dataset.\n        variables: Optional variable name or list of variable names to reproject.\n            If None, all suitable variables are processed.\n        interp_methods: Optional interpolation method to be used for upsampling spatial\n            data variables. Can be a single interpolation method for all variables or a\n            dictionary mapping variable names or dtypes to interpolation method.\n            Supported methods include:\n\n            - `0` (nearest neighbor)\n            - `1` (linear / bilinear)\n            - `\"nearest\"`\n            - `\"triangular\"`\n            - `\"bilinear\"`\n\n            The default is `0` for integer arrays, else `1`.\n        agg_methods: Optional aggregation methods for downsampling spatial variables.\n            Can be a single method for all variables or a dictionary mapping variable\n            names or dtypes to methods. Supported methods include:\n                \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",\n                \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\".\n            Defaults to \"center\" for integer arrays, else \"mean\".\n        recover_nans: Optional boolean or mapping to enable NaN recovery during\n            upsampling (only applies when interpolation method is not nearest).\n            Can be a single boolean or a dictionary mapping variable names or dtypes\n            to booleans. Defaults to False.\n        fill_values: Optional fill value(s) to assign outside source coverage.\n            Can be a single value or dictionary by variable or type. If not set,\n            defaults are:\n\n            - float: NaN\n            - uint8: 255\n            - uint16: 65535\n            - other integers: -1\n\n    Returns:\n        A new dataset with variables reprojected to the target CRS and\n            grid. Variables without 2D spatial dimensions are copied as-is.\n            1D spatial coordinate variables are ignored in the output.\n    \"\"\"\n\n    if source_gm is None:\n        source_gm = GridMapping.from_dataset(source_ds)\n    source_ds = normalize_grid_mapping(source_ds, source_gm)\n\n    source_ds = _select_variables(source_ds, variables)\n\n    transformer = pyproj.Transformer.from_crs(\n        target_gm.crs, source_gm.crs, always_xy=True\n    )\n\n    # If source has higher resolution than target, downscale first, then reproject\n    source_ds, source_gm = _downscale_source_dataset(\n        source_ds,\n        source_gm,\n        target_gm,\n        transformer,\n        interp_methods,\n        agg_methods,\n        recover_nans,\n    )\n\n    # For each bounding box in the target grid mapping:\n    # - determine the indices of the bbox in the source dataset\n    # - extract the corresponding coordinates for each bbox in the source dataset\n    # - compute the pad_width to handle areas requested by target_gm that exceed the\n    #   bounds of source_gm.\n    scr_ij_bboxes, x_coords, y_coords, pad_width = _get_scr_bboxes_indices(\n        transformer, source_gm, target_gm\n    )\n\n    # transform grid points from target grid mapping to source grid mapping\n    source_xx, source_yy = _transform_gridpoints(transformer, target_gm)\n\n    # reproject dataset\n    x_name, y_name = source_gm.xy_var_names\n    coords = source_ds.coords.to_dataset()\n    coords = coords.drop_vars((x_name, y_name))\n    x_name, y_name = target_gm.xy_var_names\n    coords[x_name] = target_gm.x_coords\n    coords[y_name] = target_gm.y_coords\n    coords[\"spatial_ref\"] = xr.DataArray(0, attrs=target_gm.crs.to_cf())\n    target_ds = xr.Dataset(coords=coords, attrs=source_ds.attrs)\n\n    yx_dims = (source_gm.xy_dim_names[1], source_gm.xy_dim_names[0])\n    for var_name, data_array in source_ds.items():\n        if data_array.dims[-2:] == yx_dims:\n            assert len(data_array.dims) in (\n                2,\n                3,\n            ), f\"Data variable {var_name} has {len(data_array.dims)} dimensions.\"\n\n            target_ds[var_name] = _reproject_data_array(\n                data_array,\n                var_name,\n                source_gm,\n                target_gm,\n                source_xx,\n                source_yy,\n                x_coords,\n                y_coords,\n                scr_ij_bboxes,\n                pad_width,\n                interp_methods,\n                fill_values,\n            )\n        elif yx_dims[0] not in data_array.dims and yx_dims[1] not in data_array.dims:\n            target_ds[var_name] = data_array\n\n    return target_ds\n</code></pre>"},{"location":"api/#xcube_resampling.rectify.rectify_dataset","title":"<code>xcube_resampling.rectify.rectify_dataset(source_ds, target_gm=None, source_gm=None, variables=None, interp_methods=None, agg_methods=None, recover_nans=False, fill_values=None, tile_size=None)</code>","text":"<p>Rectify a dataset with non-regular grid to a regular grid defined by a target grid mapping.</p> <p>This function transforms spatial coordinates to a regular grid while preserving data values. It optionally downsamples high-resolution inputs prior to rectifying.</p> <p>Parameters:</p> Name Type Description Default <code>source_ds</code> <code>Dataset</code> <p>The source dataset with 2D spatial coordinate variables.</p> required <code>target_gm</code> <code>GridMapping | None</code> <p>Optional target grid mapping defining the output regular grid. If not provided, one is derived from the source grid mapping.</p> <code>None</code> <code>source_gm</code> <code>GridMapping | None</code> <p>Optional grid mapping of the source dataset. If not given, it is inferred from the dataset.</p> <code>None</code> <code>variables</code> <code>str | Iterable[str] | None</code> <p>Optional variable(s) to rectify. If None, all eligible variables are processed.</p> <code>None</code> <code>interp_methods</code> <code>InterpMethods | None</code> <p>Optional interpolation method to be used for upsampling spatial data variables. Can be a single interpolation method for all variables or a dictionary mapping variable names or dtypes to interpolation method. Supported methods include:</p> <ul> <li><code>0</code> (nearest neighbor)</li> <li><code>1</code> (linear / bilinear)</li> <li><code>\"nearest\"</code></li> <li><code>\"triangular\"</code></li> <li><code>\"bilinear\"</code></li> </ul> <p>The default is <code>0</code> for integer arrays, else <code>1</code>.</p> <code>None</code> <code>agg_methods</code> <code>AggMethods | None</code> <p>Optional aggregation methods for downsampling spatial variables. Can be a single method for all variables or a dictionary mapping variable names or dtypes to methods. Supported methods include:     \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",     \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\". Defaults to \"center\" for integer arrays, else \"mean\".</p> <code>None</code> <code>recover_nans</code> <code>RecoverNans</code> <p>Optional boolean or mapping to enable NaN recovery during upsampling (only applies when interpolation method is not nearest). Can be a single boolean or a dictionary mapping variable names or dtypes to booleans. Defaults to False.</p> <code>False</code> <code>fill_values</code> <code>FillValues | None</code> <p>Optional fill value(s) for areas outside input coverage. Can be a single value or dictionary by variable or type. If not provided, defaults based on data type are used:</p> <ul> <li>float: NaN</li> <li>uint8: 255</li> <li>uint16: 65535</li> <li>other ints: -1</li> </ul> <code>None</code> <code>tile_size</code> <code>int | tuple[int, int] | None</code> <p>Optional tile size for inferring a regular grid, if <code>target_gm</code> is not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>A new dataset with spatial variables rectified to a regular grid. Variables not having 2D spatial dimensions are copied as-is. 1D spatial coordinate variables are ignored in the output.</p> Source code in <code>xcube_resampling/rectify.py</code> <pre><code>def rectify_dataset(\n    source_ds: xr.Dataset,\n    target_gm: GridMapping | None = None,\n    source_gm: GridMapping | None = None,\n    variables: str | Iterable[str] | None = None,\n    interp_methods: InterpMethods | None = None,\n    agg_methods: AggMethods | None = None,\n    recover_nans: RecoverNans = False,\n    fill_values: FillValues | None = None,\n    tile_size: int | tuple[int, int] | None = None,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Rectify a dataset with non-regular grid to a regular grid defined by a target\n    grid mapping.\n\n    This function transforms spatial coordinates to a regular grid while preserving\n    data values. It optionally downsamples high-resolution inputs prior to rectifying.\n\n    Args:\n        source_ds: The source dataset with 2D spatial coordinate variables.\n        target_gm: Optional target grid mapping defining the output regular grid.\n            If not provided, one is derived from the source grid mapping.\n        source_gm: Optional grid mapping of the source dataset. If not given, it is\n            inferred from the dataset.\n        variables: Optional variable(s) to rectify. If None, all eligible variables\n            are processed.\n        interp_methods: Optional interpolation method to be used for upsampling spatial\n            data variables. Can be a single interpolation method for all variables or a\n            dictionary mapping variable names or dtypes to interpolation method.\n            Supported methods include:\n\n            - `0` (nearest neighbor)\n            - `1` (linear / bilinear)\n            - `\"nearest\"`\n            - `\"triangular\"`\n            - `\"bilinear\"`\n\n            The default is `0` for integer arrays, else `1`.\n        agg_methods: Optional aggregation methods for downsampling spatial variables.\n            Can be a single method for all variables or a dictionary mapping variable\n            names or dtypes to methods. Supported methods include:\n                \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",\n                \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\".\n            Defaults to \"center\" for integer arrays, else \"mean\".\n        recover_nans: Optional boolean or mapping to enable NaN recovery during\n            upsampling (only applies when interpolation method is not nearest).\n            Can be a single boolean or a dictionary mapping variable names or dtypes\n            to booleans. Defaults to False.\n        fill_values: Optional fill value(s) for areas outside input coverage.\n            Can be a single value or dictionary by variable or type. If not provided,\n            defaults based on data type are used:\n\n            - float: NaN\n            - uint8: 255\n            - uint16: 65535\n            - other ints: -1\n\n        tile_size: Optional tile size for inferring a regular grid, if `target_gm` is\n            not provided.\n\n    Returns:\n        A new dataset with spatial variables rectified to a regular grid.\n            Variables not having 2D spatial dimensions are copied as-is. 1D spatial\n            coordinate variables are ignored in the output.\n    \"\"\"\n    if source_gm is None:\n        source_gm = GridMapping.from_dataset(source_ds)\n    source_ds = normalize_grid_mapping(source_ds, source_gm)\n\n    if target_gm is None:\n        target_gm = source_gm.to_regular(tile_size=tile_size)\n\n    # transform 2d spatial coordinate of source dataset to target CRS\n    if not _is_equal_crs(source_gm, target_gm):\n        source_ds = _transform_coords(source_ds, source_gm, target_gm)\n        source_gm = GridMapping.from_dataset(source_ds)\n\n    source_ds = _select_variables(source_ds, variables)\n\n    # ToDo: clip dataset\n\n    # If source has higher resolution than target, downscale first, then rectify\n    source_ds, source_gm = _downscale_source_dataset(\n        source_ds,\n        source_gm,\n        target_gm,\n        interp_methods,\n        agg_methods,\n        recover_nans,\n    )\n\n    # calculate source indices in target grid-mapping\n    target_source_ij = _compute_target_source_ij(source_gm, target_gm, UV_DELTA)\n\n    # rectify dataset\n    x_name, y_name = source_gm.xy_var_names\n    coords = source_ds.coords.to_dataset()\n    coords = coords.drop_vars((x_name, y_name))\n    x_name, y_name = target_gm.xy_var_names\n    target_coords = target_gm.to_coords()\n    coords[x_name] = target_coords[x_name]\n    coords[y_name] = target_coords[y_name]\n    coords[\"spatial_ref\"] = xr.DataArray(0, attrs=target_gm.crs.to_cf())\n    target_ds = xr.Dataset(coords=coords, attrs=source_ds.attrs)\n\n    yx_dims = (source_gm.xy_dim_names[1], source_gm.xy_dim_names[0])\n    for var_name, data_array in source_ds.items():\n        if var_name in target_gm.xy_var_names:\n            continue\n        if data_array.dims[-2:] == yx_dims:\n            assert len(data_array.dims) in (\n                2,\n                3,\n            ), f\"Data variable {var_name} has {len(data_array.dims)} dimensions.\"\n\n            target_ds[var_name] = _rectify_data_array(\n                data_array,\n                var_name,\n                target_gm,\n                target_source_ij,\n                interp_methods,\n                fill_values,\n            )\n\n        elif yx_dims[0] not in data_array.dims and yx_dims[1] not in data_array.dims:\n            target_ds[var_name] = data_array\n\n    return target_ds\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping","title":"<code>xcube_resampling.gridmapping.GridMapping</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract base class for grid mappings that define an image grid and a transformation from image pixel coordinates to spatial Earth coordinates defined in a well-known coordinate reference system (CRS).</p> <p>This class cannot be instantiated directly. Use one of its factory methods to create instances:</p> <ul> <li>:meth:<code>regular</code></li> <li>:meth:<code>from_dataset</code></li> <li>:meth:<code>from_coords</code></li> </ul> <p>Some instance methods can be used to derive new instances:</p> <ul> <li>:meth:<code>derive</code></li> <li>:meth:<code>scale</code></li> <li>:meth:<code>transform</code></li> <li>:meth:<code>to_regular</code></li> </ul> <p>This class is thread-safe.</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>class GridMapping(abc.ABC):\n    \"\"\"An abstract base class for grid mappings that define an image grid and\n    a transformation from image pixel coordinates to spatial Earth coordinates\n    defined in a well-known coordinate reference system (CRS).\n\n    This class cannot be instantiated directly. Use one of its factory methods\n    to create instances:\n\n    * :meth:`regular`\n    * :meth:`from_dataset`\n    * :meth:`from_coords`\n\n    Some instance methods can be used to derive new instances:\n\n    * :meth:`derive`\n    * :meth:`scale`\n    * :meth:`transform`\n    * :meth:`to_regular`\n\n    This class is thread-safe.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        /,\n        size: int | tuple[int, int],\n        tile_size: int | tuple[int, int] | None,\n        xy_bbox: tuple[FloatInt, FloatInt, FloatInt, FloatInt],\n        xy_res: FloatInt | tuple[FloatInt, FloatInt],\n        crs: pyproj.crs.CRS,\n        xy_var_names: tuple[str, str],\n        xy_dim_names: tuple[str, str],\n        is_regular: bool | None = None,\n        is_lon_360: bool | None = None,\n        is_j_axis_up: bool | None = None,\n        x_coords: xr.DataArray | None = None,\n        y_coords: xr.DataArray | None = None,\n        xy_coords: xr.DataArray | None = None,\n    ):\n        width, height = _normalize_int_pair(size, name=\"size\")\n        assert_true(width &gt; 1 and height &gt; 1, \"invalid size\")\n\n        tile_width, tile_height = _normalize_int_pair(\n            tile_size, default=(width, height)\n        )\n        assert_true(tile_width &gt; 1 and tile_height &gt; 1, \"invalid tile_size\")\n\n        assert_given(xy_bbox, name=\"xy_bbox\")\n        assert_given(xy_res, name=\"xy_res\")\n        _assert_valid_xy_names(xy_var_names, name=\"xy_var_names\")\n        _assert_valid_xy_names(xy_dim_names, name=\"xy_dim_names\")\n        assert_instance(crs, pyproj.crs.CRS, name=\"crs\")\n\n        if x_coords is not None:\n            assert_instance(x_coords, xr.DataArray, name=\"x_coords\")\n            assert_true(\n                x_coords.ndim in (1, 2),\n                message=f\"x_coords.ndim must be 1 or 2, was {x_coords.ndim}\",\n            )\n        if y_coords is not None:\n            assert_instance(y_coords, xr.DataArray, name=\"y_coords\")\n            assert_true(\n                y_coords.ndim in (1, 2),\n                message=f\"y_coords.ndim must be 1 or 2, was {y_coords.ndim}\",\n            )\n        if xy_coords is not None:\n            assert_instance(xy_coords, xr.DataArray, name=\"xy_coords\")\n            assert_true(\n                xy_coords.shape == (2, height, width),\n                message=f\"xy_coords.shape must be\"\n                f\" {(2, height, width)},\"\n                f\" was {xy_coords.shape}\",\n            )\n\n        x_min, y_min, x_max, y_max = xy_bbox\n        x_res, y_res = _normalize_number_pair(xy_res, name=\"xy_res\")\n        assert_true(x_res &gt; 0 and y_res &gt; 0, \"invalid xy_res\")\n\n        self._lock = threading.RLock()\n\n        self._size = width, height\n        self._tile_size = tile_width, tile_height\n        self._xy_bbox = x_min, y_min, x_max, y_max\n        self._xy_res = x_res, y_res\n        self._crs = crs\n        self._xy_var_names = xy_var_names\n        self._xy_dim_names = xy_dim_names\n        self._is_regular = is_regular\n        self._is_lon_360 = is_lon_360\n        self._is_j_axis_up = is_j_axis_up\n        self._x_coords = x_coords\n        self._y_coords = y_coords\n        self._xy_coords = xy_coords\n\n    def derive(\n        self,\n        /,\n        xy_var_names: tuple[str, str] = None,\n        xy_dim_names: tuple[str, str] = None,\n        tile_size: int | tuple[int, int] = None,\n        is_j_axis_up: bool = None,\n    ) -&gt; \"GridMapping\":\n        \"\"\"Derive a new grid mapping from this one with some properties changed.\n\n        Args:\n            xy_var_names: The new x-, and y-variable names.\n            xy_dim_names: The new x-, and y-dimension names.\n            tile_size: The new tile size\n            is_j_axis_up: Whether j-axis points up.\n\n        Returns:\n            A new, derived grid mapping.\n        \"\"\"\n        other = copy.copy(self)\n        if xy_var_names is not None:\n            _assert_valid_xy_names(xy_var_names, name=\"xy_var_names\")\n            other._xy_var_names = xy_var_names\n        if xy_dim_names is not None:\n            _assert_valid_xy_names(xy_dim_names, name=\"xy_dim_names\")\n            other._xy_dim_names = xy_dim_names\n        if tile_size is not None:\n            tile_width, tile_height = _normalize_int_pair(tile_size, name=\"tile_size\")\n            assert_true(tile_width &gt; 1 and tile_height &gt; 1, \"invalid tile_size\")\n            tile_size = tile_width, tile_height\n            if other.tile_size != tile_size:\n                other._tile_size = tile_width, tile_height\n                with self._lock:\n                    # if other._xy_coords has not been initialized before, we will do it\n                    # in the next line. Otherwise, the following lines raise an error\n                    if other._xy_coords is None:\n                        _ = other.xy_coords\n                    other._xy_coords = other._xy_coords.chunk(\n                        {\n                            dim: size\n                            for (dim, size) in zip(\n                                other._xy_coords.dims, other.xy_coords_chunks\n                            )\n                        }\n                    )\n        if is_j_axis_up is not None and is_j_axis_up != other._is_j_axis_up:\n            other._is_j_axis_up = is_j_axis_up\n            if other._y_coords is not None:\n                other._y_coords = other._y_coords[::-1]\n            if other._xy_coords is not None:\n                other._xy_coords = other._xy_coords[:, ::-1, :]\n                other._xy_coords = other._xy_coords.chunk(\n                    {\n                        dim: size\n                        for (dim, size) in zip(\n                            other._xy_coords.dims, other.xy_coords_chunks\n                        )\n                    }\n                )\n\n        return other\n\n    def scale(\n        self,\n        xy_scale: FloatInt | tuple[FloatInt, FloatInt],\n        tile_size: int | tuple[int, int] | None = None,\n    ) -&gt; \"GridMapping\":\n        \"\"\"Derive a scaled version of this regular grid mapping.\n\n        Scaling factors larger than one correspond to up-scaling\n        (pixels sizes decrease, image size increases).\n\n        Scaling factors lower than one correspond to down-scaling.\n        (pixels sizes increase, image size decreases).\n\n        Args:\n            xy_scale: The x-, and y-scaling factors. May be a single\n                number or tuple.\n            tile_size: The new tile size\n\n        Returns:\n            A new, scaled grid mapping.\n        \"\"\"\n        self._assert_regular()\n        x_scale, y_scale = _normalize_number_pair(xy_scale)\n        new_xy_res, new_size = scale_xy_res_and_size(\n            self.xy_res, self.size, (x_scale, y_scale)\n        )\n        if tile_size is not None:\n            tile_width, tile_height = _normalize_int_pair(tile_size, name=\"tile_size\")\n        else:\n            tile_width, tile_height = self.tile_size\n        tile_width = min(new_size[0], tile_width)\n        tile_height = min(new_size[1], tile_height)\n        return self.regular(\n            new_size,\n            (self.x_min, self.y_min),\n            new_xy_res,\n            self.crs,\n            tile_size=(tile_width, tile_height),\n            is_j_axis_up=self.is_j_axis_up,\n        ).derive(xy_dim_names=self.xy_dim_names, xy_var_names=self.xy_var_names)\n\n    @property\n    def size(self) -&gt; tuple[int, int]:\n        \"\"\"Image size (width, height) in pixels.\"\"\"\n        return self._size\n\n    @property\n    def width(self) -&gt; int:\n        \"\"\"Image width in pixels.\"\"\"\n        return self.size[0]\n\n    @property\n    def height(self) -&gt; int:\n        \"\"\"Image height in pixels.\"\"\"\n        return self.size[1]\n\n    @property\n    def tile_size(self) -&gt; tuple[int, int]:\n        \"\"\"Image tile size (width, height) in pixels.\"\"\"\n        return self._tile_size\n\n    @property\n    def is_tiled(self) -&gt; bool:\n        \"\"\"Whether the image is tiled.\"\"\"\n        return self.size != self.tile_size\n\n    @property\n    def tile_width(self) -&gt; int:\n        \"\"\"Image tile width in pixels.\"\"\"\n        return self.tile_size[0]\n\n    @property\n    def tile_height(self) -&gt; int:\n        \"\"\"Image tile height in pixels.\"\"\"\n        return self.tile_size[1]\n\n    @property\n    def x_coords(self):\n        \"\"\"The 1D or 2D x-coordinate array of\n        shape (width,) or (height, width).\n        \"\"\"\n        return self._get_computed_attribute(\"_x_coords\", self._new_x_coords)\n\n    @abc.abstractmethod\n    def _new_x_coords(self) -&gt; xr.DataArray:\n        \"\"\"Create new 1D or 2D x-coordinate array of\n        shape (width,) or (height, width).\n        \"\"\"\n\n    @property\n    def y_coords(self):\n        \"\"\"The 1D or 2D y-coordinate array of\n        shape (width,) or (height, width).\n        \"\"\"\n        return self._get_computed_attribute(\"_y_coords\", self._new_y_coords)\n\n    @abc.abstractmethod\n    def _new_y_coords(self) -&gt; xr.DataArray:\n        \"\"\"Create new 1D or 2D y-coordinate array of\n        shape (width,) or (height, width).\n        \"\"\"\n\n    @property\n    def xy_coords(self) -&gt; xr.DataArray:\n        \"\"\"The x,y coordinates as data array of shape (2, height, width).\n        Coordinates are given in units of the CRS.\n        \"\"\"\n        xy_coords = self._get_computed_attribute(\"_xy_coords\", self._new_xy_coords)\n        _assert_valid_xy_coords(xy_coords)\n        return xy_coords\n\n    @property\n    def xy_coords_chunks(self) -&gt; tuple[int, int, int]:\n        \"\"\"Get the chunks for the *xy_coords* array.\"\"\"\n        return 2, self.tile_height, self.tile_width\n\n    @abc.abstractmethod\n    def _new_xy_coords(self) -&gt; xr.DataArray:\n        \"\"\"Create new coordinate array of shape (2, height, width).\"\"\"\n\n    def _get_computed_attribute(self, name: str, computer: Callable[[], Any]) -&gt; Any:\n        \"\"\"Get the value for a computed attribute.\n        Utility to be used by this and derived classes.\n        \"\"\"\n        value = getattr(self, name)\n        if value is not None:\n            return value\n        with self._lock:\n            # Double null check\n            value = getattr(self, name)\n            if value is not None:\n                return value\n            value = computer()\n            setattr(self, name, value)\n            return value\n\n    @property\n    def xy_var_names(self) -&gt; tuple[str, str]:\n        \"\"\"The variable names of the x,y coordinates as\n        tuple (x_var_name, y_var_name).\n        \"\"\"\n        return self._xy_var_names\n\n    @property\n    def xy_dim_names(self) -&gt; tuple[str, str]:\n        \"\"\"The dimension names of the x,y coordinates as\n        tuple (x_dim_name, y_dim_name).\n        \"\"\"\n        return self._xy_dim_names\n\n    @property\n    def xy_bbox(self) -&gt; tuple[float, float, float, float]:\n        \"\"\"The image's bounding box in CRS coordinates.\"\"\"\n        return self._xy_bbox\n\n    @property\n    def x_min(self) -&gt; FloatInt:\n        \"\"\"Minimum x-coordinate in CRS units.\"\"\"\n        return self._xy_bbox[0]\n\n    @property\n    def y_min(self) -&gt; FloatInt:\n        \"\"\"Minimum y-coordinate in CRS units.\"\"\"\n        return self._xy_bbox[1]\n\n    @property\n    def x_max(self) -&gt; FloatInt:\n        \"\"\"Maximum x-coordinate in CRS units.\"\"\"\n        return self._xy_bbox[2]\n\n    @property\n    def y_max(self) -&gt; FloatInt:\n        \"\"\"Maximum y-coordinate in CRS units.\"\"\"\n        return self._xy_bbox[3]\n\n    @property\n    def xy_res(self) -&gt; tuple[FloatInt, FloatInt]:\n        \"\"\"Pixel size in x and y direction.\"\"\"\n        return self._xy_res\n\n    @property\n    def x_res(self) -&gt; FloatInt:\n        \"\"\"Pixel size in CRS units per pixel in x-direction.\"\"\"\n        return self._xy_res[0]\n\n    @property\n    def y_res(self) -&gt; FloatInt:\n        \"\"\"Pixel size in CRS units per pixel in y-direction.\"\"\"\n        return self._xy_res[1]\n\n    @property\n    def crs(self) -&gt; pyproj.crs.CRS:\n        \"\"\"The coordinate reference system.\"\"\"\n        return self._crs\n\n    @property\n    def spatial_unit_name(self) -&gt; str:\n        return self._crs.axis_info[0].unit_name\n\n    @property\n    def is_lon_360(self) -&gt; bool | None:\n        \"\"\"Check whether *x_max* is greater than 180 degrees.\n        Effectively tests whether the range *x_min*, *x_max* crosses\n        the anti-meridian at 180 degrees.\n        Works only for geographical coordinate reference systems.\n        \"\"\"\n        return self._is_lon_360\n\n    @property\n    def is_regular(self) -&gt; bool | None:\n        \"\"\"Do the x,y coordinates for a regular grid?\n        A regular grid has a constant delta in both\n        x- and y-directions of the x- and y-coordinates.\n\n        Returns: None, if this property cannot be determined,\n            True or False otherwise.\n        \"\"\"\n        return self._is_regular\n\n    @property\n    def is_j_axis_up(self) -&gt; bool | None:\n        \"\"\"Does the positive image j-axis point up?\n        By default, the positive image j-axis points down.\n\n        Returns: None, if this property cannot be determined,\n            True or False otherwise.\n        \"\"\"\n        return self._is_j_axis_up\n\n    @property\n    def ij_to_xy_transform(self) -&gt; AffineTransformMatrix:\n        \"\"\"The affine transformation matrix from image to CRS coordinates.\n        Defined only for grid mappings with rectified x,y coordinates.\n        \"\"\"\n        self._assert_regular()\n        if self.is_j_axis_up:\n            return (\n                (self.x_res, 0.0, self.x_min),\n                (0.0, self.y_res, self.y_min),\n            )\n        else:\n            return (\n                (self.x_res, 0.0, self.x_min),\n                (0.0, -self.y_res, self.y_max),\n            )\n\n    @property\n    def xy_to_ij_transform(self) -&gt; AffineTransformMatrix:\n        \"\"\"The affine transformation matrix from CRS to image coordinates.\n        Defined only for grid mappings with rectified x,y coordinates.\n        \"\"\"\n        self._assert_regular()\n        return _from_affine(~_to_affine(self.ij_to_xy_transform))\n\n    def ij_transform_to(self, other: \"GridMapping\") -&gt; AffineTransformMatrix:\n        \"\"\"Get the affine transformation matrix that transforms\n        image coordinates of *other* into image coordinates\n        of this image geometry.\n\n        Defined only for grid mappings with rectified x,y coordinates.\n\n        Args:\n            other: The other image geometry\n\n        Returns:\n            Affine transformation matrix\n        \"\"\"\n        self._assert_regular()\n        self.assert_regular(other, name=\"other\")\n        a = _to_affine(self.ij_to_xy_transform)\n        b = _to_affine(other.xy_to_ij_transform)\n        return _from_affine(b * a)\n\n    def ij_transform_from(self, other: \"GridMapping\") -&gt; AffineTransformMatrix:\n        \"\"\"Get the affine transformation matrix that transforms\n        image coordinates of this image geometry to image\n        coordinates of *other*.\n\n        Defined only for grid mappings with rectified x,y coordinates.\n\n        Args:\n            other: The other image geometry\n\n        Returns:\n            Affine transformation matrix\n        \"\"\"\n        self._assert_regular()\n        self.assert_regular(other, name=\"other\")\n        a = _to_affine(self.ij_transform_to(other))\n        return _from_affine(~a)\n\n    @property\n    def ij_bbox(self) -&gt; tuple[int, int, int, int]:\n        \"\"\"The image's bounding box in pixel coordinates.\"\"\"\n        return 0, 0, self.width, self.height\n\n    @property\n    def ij_bboxes(self) -&gt; np.ndarray:\n        \"\"\"The image tiles' bounding boxes in image pixel coordinates.\"\"\"\n        chunk_sizes = get_chunk_sizes(\n            (self.height, self.width), (self.tile_height, self.tile_width)\n        )\n        _, _, block_slices = get_block_iterators(chunk_sizes)\n        block_slices = tuple(block_slices)\n        n = len(block_slices)\n        ij_bboxes = np.ndarray((n, 4), dtype=np.int64)\n        for i in range(n):\n            y_slice, x_slice = block_slices[i]\n            ij_bboxes[i, 0] = x_slice.start\n            ij_bboxes[i, 1] = y_slice.start\n            ij_bboxes[i, 2] = x_slice.stop\n            ij_bboxes[i, 3] = y_slice.stop\n        return ij_bboxes\n\n    @property\n    def xy_bboxes(self) -&gt; np.ndarray:\n        \"\"\"The image tiles' bounding boxes in CRS coordinates.\"\"\"\n        if self.is_j_axis_up:\n            xy_offset = np.array([self.x_min, self.y_min, self.x_min, self.y_min])\n            xy_scale = np.array([self.x_res, self.y_res, self.x_res, self.y_res])\n            xy_bboxes = xy_offset + xy_scale * self.ij_bboxes\n        else:\n            xy_offset = np.array([self.x_min, self.y_max, self.x_min, self.y_max])\n            xy_scale = np.array([self.x_res, -self.y_res, self.x_res, -self.y_res])\n            xy_bboxes = xy_offset + xy_scale * self.ij_bboxes\n            xy_bboxes[:, [1, 3]] = xy_bboxes[:, [3, 1]]\n        return xy_bboxes\n\n    def ij_bbox_from_xy_bbox(\n        self,\n        xy_bbox: tuple[float, float, float, float],\n        xy_border: float = 0.0,\n        ij_border: int = 0,\n    ) -&gt; tuple[int, int, int, int]:\n        \"\"\"Compute bounding box in i,j pixel coordinates given a\n        bounding box *xy_bbox* in x,y coordinates.\n\n        Args:\n            xy_bbox: Box (x_min, y_min, x_max, y_max) given in the same\n                CS as x and y.\n            xy_border: If non-zero, grows the bounding box *xy_bbox*\n                before using it for comparisons. Defaults to 0.\n            ij_border: If non-zero, grows the returned i,j bounding box\n                and clips it to size. Defaults to 0.\n\n        Returns:\n            Bounding box in (i_min, j_min, i_max, j_max) in pixel\n            coordinates. Returns ``(-1, -1, -1, -1)`` if *xy_bbox* isn't\n            intersecting any of the x,y coordinates.\n        \"\"\"\n        xy_bboxes = np.array([xy_bbox], dtype=np.float64)\n        ij_bboxes = np.full_like(xy_bboxes, -1, dtype=np.int64)\n        self.ij_bboxes_from_xy_bboxes(\n            xy_bboxes, xy_border=xy_border, ij_border=ij_border, ij_bboxes=ij_bboxes\n        )\n        # noinspection PyTypeChecker\n        return tuple(map(int, ij_bboxes[0]))\n\n    def ij_bboxes_from_xy_bboxes(\n        self,\n        xy_bboxes: np.ndarray,\n        xy_border: float = 0.0,\n        ij_border: int = 0,\n        ij_bboxes: np.ndarray = None,\n    ) -&gt; np.ndarray:\n        \"\"\"Compute bounding boxes in pixel coordinates given bounding boxes\n        *xy_bboxes* [[x_min, y_min, x_max, y_max], ...] in x,y coordinates.\n\n        The returned array in i,j pixel coordinates\n        has the same shape as *xy_bboxes*. The value ranges in the\n        returned array [[i_min, j_min, i_max, j_max], ..]] are:\n\n        * i_min from 0 to width-1, i_max from 1 to width;\n        * j_min from 0 to height-1, j_max from 1 to height;\n\n        so the i,j pixel coordinates can be used as array index slices.\n\n        Args:\n            xy_bboxes: Numpy array of x,y bounding boxes [[x_min, y_min,\n                x_max, y_max], ...] given in the same CS as x and y.\n            xy_border: If non-zero, grows the bounding box *xy_bbox*\n                before using it for comparisons. Defaults to 0.\n            ij_border: If non-zero, grows the returned i,j bounding box\n                and clips it to size. Defaults to 0.\n            ij_bboxes: Numpy array of pixel i,j bounding boxes [[x_min,\n                y_min, x_max, y_max], ...]. If given, must have same\n                shape as *xy_bboxes*.\n\n        Returns:\n            Bounding boxes in [[i_min, j_min, i_max, j_max], ..]] in\n            pixel coordinates.\n        \"\"\"\n        if ij_bboxes is None:\n            ij_bboxes = np.full_like(xy_bboxes, -1, dtype=np.int64)\n        else:\n            ij_bboxes[:, :] = -1\n        xy_coords = self.xy_coords\n        return self._compute_ij_bboxes_dask(\n            xy_coords[0], xy_coords[1], xy_bboxes, xy_border, ij_border, ij_bboxes\n        )\n\n    def _compute_ij_bboxes_dask(\n        self,\n        x_coords: xr.DataArray,\n        y_coords: xr.DataArray,\n        xy_bboxes: np.ndarray,\n        xy_border: float,\n        ij_border: int,\n        ij_bboxes: np.ndarray,\n    ):\n        from .bboxes import compute_ij_bboxes\n\n        da.map_blocks(\n            compute_ij_bboxes,\n            x_coords.values,\n            y_coords.values,\n            xy_bboxes,\n            xy_border,\n            ij_border,\n            ij_bboxes,\n            dtype=ij_bboxes.dtype,\n        ).compute()\n        return ij_bboxes\n\n    def to_dataset_attrs(self) -&gt; Mapping[str, Any]:\n        \"\"\"Get spatial dataset attributes as recommended by\n        https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3#Recommended\n\n        Returns:\n            dictionary with dataset coordinate attributes.\n        \"\"\"\n\n        x1, y1, x2, y2 = self.xy_bbox\n\n        if self.crs.is_geographic:\n            lon_min, lat_min, lon_max, lat_max = self.xy_bbox\n            lon_res, lat_res = self.xy_res\n        else:\n            x_res, y_res = self.xy_res\n            # center position\n            xm1 = (x1 + x2) / 2\n            ym1 = (y1 + y2) / 2\n            # center position + delta\n            xm2 = xm1 + x_res\n            ym2 = ym1 + y_res\n            transformer = pyproj.Transformer.from_crs(\n                crs_from=self.crs, crs_to=CRS_CRS84\n            )\n            xx, yy = transformer.transform((x1, x2, xm1, xm2), (y1, y2, ym1, ym2))\n            lon_min, lon_max, lon_m1, lon_m2 = xx\n            lat_min, lat_max, lat_m1, lat_m2 = yy\n            # Estimate resolution (note, this may be VERY wrong)\n            lon_res = abs(lon_m2 - lon_m1)\n            lat_res = abs(lat_m2 - lat_m1)\n\n        geospatial_bounds_crs = \"CRS84\"\n        geospatial_bounds = (\n            f\"POLYGON((\"\n            f\"{lon_min} {lat_min}, \"\n            f\"{lon_min} {lat_max}, \"\n            f\"{lon_max} {lat_max}, \"\n            f\"{lon_max} {lat_min}, \"\n            f\"{lon_min} {lat_min}\"\n            f\"))\"\n        )\n\n        return dict(\n            geospatial_lon_units=\"degrees_east\",\n            geospatial_lon_min=lon_min,\n            geospatial_lon_max=lon_max,\n            geospatial_lon_resolution=lon_res,\n            geospatial_lat_units=\"degrees_north\",\n            geospatial_lat_min=lat_min,\n            geospatial_lat_max=lat_max,\n            geospatial_lat_resolution=lat_res,\n            geospatial_bounds_crs=geospatial_bounds_crs,\n            geospatial_bounds=geospatial_bounds,\n        )\n\n    def to_coords(\n        self,\n        xy_var_names: tuple[str, str] = None,\n        xy_dim_names: tuple[str, str] = None,\n        exclude_bounds: bool = False,\n        reuse_coords: bool = False,\n    ) -&gt; Mapping[str, xr.DataArray]:\n        \"\"\"Get CF-compliant axis coordinate variables and cell boundary\n        coordinate variables.\n\n        Defined only for grid mappings with regular x,y coordinates.\n\n        Args:\n            xy_var_names: Optional coordinate variable names\n                (x_var_name, y_var_name).\n            xy_dim_names: Optional coordinate dimensions names\n                (x_dim_name, y_dim_name).\n            exclude_bounds: If True, do not create bounds coordinates.\n                Defaults to False.\n            reuse_coords: Whether to either reuse target coordinate\n                arrays from target_gm or to compute new ones.\n\n        Returns:\n            dictionary with coordinate variables\n        \"\"\"\n        self._assert_regular()\n        from .coords import grid_mapping_to_coords\n\n        return grid_mapping_to_coords(\n            self,\n            xy_var_names=xy_var_names,\n            xy_dim_names=xy_dim_names,\n            exclude_bounds=exclude_bounds,\n            reuse_coords=reuse_coords,\n        )\n\n    def transform(\n        self,\n        crs: str | pyproj.crs.CRS,\n        *,\n        xy_res: FloatInt | tuple[FloatInt, FloatInt] = None,\n        tile_size: int | tuple[int, int] = None,\n        xy_var_names: tuple[str, str] = None,\n        tolerance: float = DEFAULT_TOLERANCE,\n    ) -&gt; \"GridMapping\":\n        \"\"\"Transform this grid mapping so it uses the given\n        spatial coordinate reference system into another *crs*.\n\n        Args:\n            crs: The new spatial coordinate reference system.\n            xy_res: Optional resolution in x- and y-directions.\n                If given, speeds up the method by avoiding time-consuming\n                spatial resolution estimation.\n            tile_size: Optional new tile size.\n            xy_var_names: Optional new coordinate names.\n            tolerance: Absolute tolerance used when comparing\n                coordinates with each other. Must be in the units of the\n                *crs* and must be greater zero.\n\n        Returns:\n            A new grid mapping that uses *crs*.\n        \"\"\"\n        from .transform import transform_grid_mapping\n\n        return transform_grid_mapping(\n            self,\n            crs,\n            xy_res=xy_res,\n            tile_size=tile_size,\n            xy_var_names=xy_var_names,\n            tolerance=tolerance,\n        )\n\n    @classmethod\n    def regular(\n        cls,\n        size: int | tuple[int, int],\n        xy_min: tuple[float, float],\n        xy_res: float | tuple[float, float],\n        crs: str | pyproj.crs.CRS,\n        *,\n        tile_size: int | tuple[int, int] = None,\n        is_j_axis_up: bool = False,\n    ) -&gt; \"GridMapping\":\n        \"\"\"Create a new regular grid mapping.\n\n        Args:\n            size: Size in pixels.\n            xy_min: Minimum x- and y-coordinates.\n            xy_res: Resolution in x- and y-directions.\n            crs: Spatial coordinate reference system.\n            tile_size: Optional tile size.\n            is_j_axis_up: Whether positive j-axis points up. Defaults to\n                false.\n\n        Returns:\n            A new regular grid mapping.\n        \"\"\"\n        from .regular import new_regular_grid_mapping\n\n        return new_regular_grid_mapping(\n            size=size,\n            xy_min=xy_min,\n            xy_res=xy_res,\n            crs=crs,\n            tile_size=tile_size,\n            is_j_axis_up=is_j_axis_up,\n        )\n\n    def to_regular(\n        self, tile_size: int | tuple[int, int] | None = None, is_j_axis_up: bool = False\n    ) -&gt; \"GridMapping\":\n        \"\"\"Transform this grid mapping into one that is regular.\n\n        Args:\n            tile_size: Optional tile size.\n            is_j_axis_up: Whether positive j-axis points up. Defaults to\n                false.\n\n        Returns:\n            A new regular grid mapping or this grid mapping, if it is\n            already regular.\n        \"\"\"\n        from .regular import to_regular_grid_mapping\n\n        return to_regular_grid_mapping(\n            self, tile_size=tile_size, is_j_axis_up=is_j_axis_up\n        )\n\n    @classmethod\n    def from_dataset(\n        cls,\n        dataset: xr.Dataset,\n        *,\n        crs: str | pyproj.crs.CRS | None = None,\n        tile_size: int | tuple[int, int] | None = None,\n        prefer_is_regular: bool = True,\n        prefer_crs: str | pyproj.crs.CRS | None = None,\n        emit_warnings: bool = False,\n        tolerance: float = DEFAULT_TOLERANCE,\n    ) -&gt; \"GridMapping\":\n        \"\"\"Create a grid mapping for the given *dataset*.\n\n        Args:\n            dataset: The dataset.\n            crs: Optional spatial coordinate reference system.\n            tile_size: Optional tile size\n            prefer_is_regular: Whether to prefer a regular grid mapping\n                if multiple found. Default is True.\n            prefer_crs: The preferred CRS of a grid mapping if multiple\n                found.\n            emit_warnings: Whether to emit warning for non-CF compliant\n                datasets.\n            tolerance: Absolute tolerance used when comparing\n                coordinates with each other. Must be in the units of the\n                *crs* and must be greater zero.\n\n        Returns:\n            a new grid mapping instance.\n        \"\"\"\n        from .dataset import new_grid_mapping_from_dataset\n\n        return new_grid_mapping_from_dataset(\n            dataset=dataset,\n            crs=crs,\n            tile_size=tile_size,\n            prefer_is_regular=prefer_is_regular,\n            prefer_crs=prefer_crs,\n            emit_warnings=emit_warnings,\n            tolerance=tolerance,\n        )\n\n    @classmethod\n    def from_coords(\n        cls,\n        x_coords: xr.DataArray,\n        y_coords: xr.DataArray,\n        crs: str | pyproj.crs.CRS,\n        *,\n        tile_size: int | tuple[int, int] | None = None,\n        tolerance: float = DEFAULT_TOLERANCE,\n    ) -&gt; \"GridMapping\":\n        \"\"\"Create a grid mapping from given x- and y-coordinates\n        *x_coords*, *y_coords* and spatial coordinate reference\n        system *crs*.\n\n        Args:\n            x_coords: The x-coordinates.\n            y_coords: The y-coordinates.\n            crs: The spatial coordinate reference system.\n            tile_size: Optional tile size.\n            tolerance: Absolute tolerance used when comparing\n                coordinates with each other. Must be in the units of the\n                *crs* and must be greater zero.\n\n        Returns:\n            A new grid mapping.\n        \"\"\"\n        from .coords import new_grid_mapping_from_coords\n\n        return new_grid_mapping_from_coords(\n            x_coords=x_coords,\n            y_coords=y_coords,\n            crs=crs,\n            tile_size=tile_size,\n            tolerance=tolerance,\n        )\n\n    def is_close(\n        self, other: \"GridMapping\", tolerance: float = DEFAULT_TOLERANCE\n    ) -&gt; bool:\n        \"\"\"Tests whether this grid mapping is close to *other*.\n\n        Args:\n            other: The other grid mapping.\n            tolerance: Absolute tolerance used when comparing\n                coordinates with each other. Must be in the units of the\n                *crs* and must be greater zero.\n\n        Returns:\n            True, if so, False otherwise.\n        \"\"\"\n        if self is other:\n            return True\n        if (\n            self.is_j_axis_up == other.is_j_axis_up\n            and self.is_lon_360 == other.is_lon_360\n            and self.is_regular == other.is_regular\n            and self.size == other.size\n            and self.tile_size == other.tile_size\n            and self.crs == other.crs\n        ):\n            sxr, syr = self.xy_res\n            oxr, oyr = other.xy_res\n            if math.isclose(sxr, oxr, abs_tol=tolerance) and math.isclose(\n                syr, oyr, abs_tol=tolerance\n            ):\n                sx1, sy1, sx2, sy2 = self.xy_bbox\n                ox1, oy1, ox2, oy2 = other.xy_bbox\n                return (\n                    math.isclose(sx1, ox1, abs_tol=tolerance)\n                    and math.isclose(sy1, oy1, abs_tol=tolerance)\n                    and math.isclose(sx2, ox2, abs_tol=tolerance)\n                    and math.isclose(sy2, oy2, abs_tol=tolerance)\n                )\n        return False\n\n    @classmethod\n    def assert_regular(cls, value: Any, name: str = None):\n        assert_instance(value, GridMapping, name=name)\n        if not value.is_regular:\n            raise ValueError(f\"{name or 'value'} must be a regular grid mapping\")\n\n    def _assert_regular(self):\n        if not self.is_regular:\n            raise NotImplementedError(\n                \"Operation not implemented for non-regular grid mappings\"\n            )\n\n    def _repr_markdown_(self) -&gt; str:\n        \"\"\"Generate an IPython Notebook Markdown representation.\"\"\"\n        is_regular = self.is_regular if self.is_regular is not None else \"_unknown_\"\n        is_j_axis_up = (\n            self.is_j_axis_up if self.is_j_axis_up is not None else \"_unknown_\"\n        )\n        is_lon_360 = self.is_lon_360 if self.is_lon_360 is not None else \"_unknown_\"\n        xy_res = repr(self.xy_res) + (\"\" if self.is_regular else \"  _estimated_\")\n        return \"\\n\".join(\n            [\n                f\"class: **{self.__class__.__name__}**\",\n                f\"* is_regular: {is_regular}\",\n                f\"* is_j_axis_up: {is_j_axis_up}\",\n                f\"* is_lon_360: {is_lon_360}\",\n                f\"* crs: {self.crs}\",\n                f\"* xy_res: {xy_res}\",\n                f\"* xy_bbox: {self.xy_bbox}\",\n                f\"* ij_bbox: {self.ij_bbox}\",\n                f\"* xy_dim_names: {self.xy_dim_names}\",\n                f\"* xy_var_names: {self.xy_var_names}\",\n                f\"* size: {self.size}\",\n                f\"* tile_size: {self.tile_size}\",\n            ]\n        )\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.size","title":"<code>size</code>  <code>property</code>","text":"<p>Image size (width, height) in pixels.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.width","title":"<code>width</code>  <code>property</code>","text":"<p>Image width in pixels.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.height","title":"<code>height</code>  <code>property</code>","text":"<p>Image height in pixels.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.tile_size","title":"<code>tile_size</code>  <code>property</code>","text":"<p>Image tile size (width, height) in pixels.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.is_tiled","title":"<code>is_tiled</code>  <code>property</code>","text":"<p>Whether the image is tiled.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.tile_width","title":"<code>tile_width</code>  <code>property</code>","text":"<p>Image tile width in pixels.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.tile_height","title":"<code>tile_height</code>  <code>property</code>","text":"<p>Image tile height in pixels.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.x_coords","title":"<code>x_coords</code>  <code>property</code>","text":"<p>The 1D or 2D x-coordinate array of shape (width,) or (height, width).</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.y_coords","title":"<code>y_coords</code>  <code>property</code>","text":"<p>The 1D or 2D y-coordinate array of shape (width,) or (height, width).</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.xy_coords","title":"<code>xy_coords</code>  <code>property</code>","text":"<p>The x,y coordinates as data array of shape (2, height, width). Coordinates are given in units of the CRS.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.xy_coords_chunks","title":"<code>xy_coords_chunks</code>  <code>property</code>","text":"<p>Get the chunks for the xy_coords array.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.xy_var_names","title":"<code>xy_var_names</code>  <code>property</code>","text":"<p>The variable names of the x,y coordinates as tuple (x_var_name, y_var_name).</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.xy_dim_names","title":"<code>xy_dim_names</code>  <code>property</code>","text":"<p>The dimension names of the x,y coordinates as tuple (x_dim_name, y_dim_name).</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.xy_bbox","title":"<code>xy_bbox</code>  <code>property</code>","text":"<p>The image's bounding box in CRS coordinates.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.x_min","title":"<code>x_min</code>  <code>property</code>","text":"<p>Minimum x-coordinate in CRS units.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.y_min","title":"<code>y_min</code>  <code>property</code>","text":"<p>Minimum y-coordinate in CRS units.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.x_max","title":"<code>x_max</code>  <code>property</code>","text":"<p>Maximum x-coordinate in CRS units.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.y_max","title":"<code>y_max</code>  <code>property</code>","text":"<p>Maximum y-coordinate in CRS units.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.xy_res","title":"<code>xy_res</code>  <code>property</code>","text":"<p>Pixel size in x and y direction.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.x_res","title":"<code>x_res</code>  <code>property</code>","text":"<p>Pixel size in CRS units per pixel in x-direction.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.y_res","title":"<code>y_res</code>  <code>property</code>","text":"<p>Pixel size in CRS units per pixel in y-direction.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.crs","title":"<code>crs</code>  <code>property</code>","text":"<p>The coordinate reference system.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.is_lon_360","title":"<code>is_lon_360</code>  <code>property</code>","text":"<p>Check whether x_max is greater than 180 degrees. Effectively tests whether the range x_min, x_max crosses the anti-meridian at 180 degrees. Works only for geographical coordinate reference systems.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.is_regular","title":"<code>is_regular</code>  <code>property</code>","text":"<p>Do the x,y coordinates for a regular grid? A regular grid has a constant delta in both x- and y-directions of the x- and y-coordinates.</p> <p>None, if this property cannot be determined,</p> Type Description <code>bool | None</code> <p>True or False otherwise.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.is_j_axis_up","title":"<code>is_j_axis_up</code>  <code>property</code>","text":"<p>Does the positive image j-axis point up? By default, the positive image j-axis points down.</p> <p>None, if this property cannot be determined,</p> Type Description <code>bool | None</code> <p>True or False otherwise.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.ij_to_xy_transform","title":"<code>ij_to_xy_transform</code>  <code>property</code>","text":"<p>The affine transformation matrix from image to CRS coordinates. Defined only for grid mappings with rectified x,y coordinates.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.xy_to_ij_transform","title":"<code>xy_to_ij_transform</code>  <code>property</code>","text":"<p>The affine transformation matrix from CRS to image coordinates. Defined only for grid mappings with rectified x,y coordinates.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.ij_bbox","title":"<code>ij_bbox</code>  <code>property</code>","text":"<p>The image's bounding box in pixel coordinates.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.ij_bboxes","title":"<code>ij_bboxes</code>  <code>property</code>","text":"<p>The image tiles' bounding boxes in image pixel coordinates.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.xy_bboxes","title":"<code>xy_bboxes</code>  <code>property</code>","text":"<p>The image tiles' bounding boxes in CRS coordinates.</p>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.derive","title":"<code>derive(xy_var_names=None, xy_dim_names=None, tile_size=None, is_j_axis_up=None)</code>","text":"<p>Derive a new grid mapping from this one with some properties changed.</p> <p>Parameters:</p> Name Type Description Default <code>xy_var_names</code> <code>tuple[str, str]</code> <p>The new x-, and y-variable names.</p> <code>None</code> <code>xy_dim_names</code> <code>tuple[str, str]</code> <p>The new x-, and y-dimension names.</p> <code>None</code> <code>tile_size</code> <code>int | tuple[int, int]</code> <p>The new tile size</p> <code>None</code> <code>is_j_axis_up</code> <code>bool</code> <p>Whether j-axis points up.</p> <code>None</code> <p>Returns:</p> Type Description <code>GridMapping</code> <p>A new, derived grid mapping.</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>def derive(\n    self,\n    /,\n    xy_var_names: tuple[str, str] = None,\n    xy_dim_names: tuple[str, str] = None,\n    tile_size: int | tuple[int, int] = None,\n    is_j_axis_up: bool = None,\n) -&gt; \"GridMapping\":\n    \"\"\"Derive a new grid mapping from this one with some properties changed.\n\n    Args:\n        xy_var_names: The new x-, and y-variable names.\n        xy_dim_names: The new x-, and y-dimension names.\n        tile_size: The new tile size\n        is_j_axis_up: Whether j-axis points up.\n\n    Returns:\n        A new, derived grid mapping.\n    \"\"\"\n    other = copy.copy(self)\n    if xy_var_names is not None:\n        _assert_valid_xy_names(xy_var_names, name=\"xy_var_names\")\n        other._xy_var_names = xy_var_names\n    if xy_dim_names is not None:\n        _assert_valid_xy_names(xy_dim_names, name=\"xy_dim_names\")\n        other._xy_dim_names = xy_dim_names\n    if tile_size is not None:\n        tile_width, tile_height = _normalize_int_pair(tile_size, name=\"tile_size\")\n        assert_true(tile_width &gt; 1 and tile_height &gt; 1, \"invalid tile_size\")\n        tile_size = tile_width, tile_height\n        if other.tile_size != tile_size:\n            other._tile_size = tile_width, tile_height\n            with self._lock:\n                # if other._xy_coords has not been initialized before, we will do it\n                # in the next line. Otherwise, the following lines raise an error\n                if other._xy_coords is None:\n                    _ = other.xy_coords\n                other._xy_coords = other._xy_coords.chunk(\n                    {\n                        dim: size\n                        for (dim, size) in zip(\n                            other._xy_coords.dims, other.xy_coords_chunks\n                        )\n                    }\n                )\n    if is_j_axis_up is not None and is_j_axis_up != other._is_j_axis_up:\n        other._is_j_axis_up = is_j_axis_up\n        if other._y_coords is not None:\n            other._y_coords = other._y_coords[::-1]\n        if other._xy_coords is not None:\n            other._xy_coords = other._xy_coords[:, ::-1, :]\n            other._xy_coords = other._xy_coords.chunk(\n                {\n                    dim: size\n                    for (dim, size) in zip(\n                        other._xy_coords.dims, other.xy_coords_chunks\n                    )\n                }\n            )\n\n    return other\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.scale","title":"<code>scale(xy_scale, tile_size=None)</code>","text":"<p>Derive a scaled version of this regular grid mapping.</p> <p>Scaling factors larger than one correspond to up-scaling (pixels sizes decrease, image size increases).</p> <p>Scaling factors lower than one correspond to down-scaling. (pixels sizes increase, image size decreases).</p> <p>Parameters:</p> Name Type Description Default <code>xy_scale</code> <code>FloatInt | tuple[FloatInt, FloatInt]</code> <p>The x-, and y-scaling factors. May be a single number or tuple.</p> required <code>tile_size</code> <code>int | tuple[int, int] | None</code> <p>The new tile size</p> <code>None</code> <p>Returns:</p> Type Description <code>GridMapping</code> <p>A new, scaled grid mapping.</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>def scale(\n    self,\n    xy_scale: FloatInt | tuple[FloatInt, FloatInt],\n    tile_size: int | tuple[int, int] | None = None,\n) -&gt; \"GridMapping\":\n    \"\"\"Derive a scaled version of this regular grid mapping.\n\n    Scaling factors larger than one correspond to up-scaling\n    (pixels sizes decrease, image size increases).\n\n    Scaling factors lower than one correspond to down-scaling.\n    (pixels sizes increase, image size decreases).\n\n    Args:\n        xy_scale: The x-, and y-scaling factors. May be a single\n            number or tuple.\n        tile_size: The new tile size\n\n    Returns:\n        A new, scaled grid mapping.\n    \"\"\"\n    self._assert_regular()\n    x_scale, y_scale = _normalize_number_pair(xy_scale)\n    new_xy_res, new_size = scale_xy_res_and_size(\n        self.xy_res, self.size, (x_scale, y_scale)\n    )\n    if tile_size is not None:\n        tile_width, tile_height = _normalize_int_pair(tile_size, name=\"tile_size\")\n    else:\n        tile_width, tile_height = self.tile_size\n    tile_width = min(new_size[0], tile_width)\n    tile_height = min(new_size[1], tile_height)\n    return self.regular(\n        new_size,\n        (self.x_min, self.y_min),\n        new_xy_res,\n        self.crs,\n        tile_size=(tile_width, tile_height),\n        is_j_axis_up=self.is_j_axis_up,\n    ).derive(xy_dim_names=self.xy_dim_names, xy_var_names=self.xy_var_names)\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.ij_transform_to","title":"<code>ij_transform_to(other)</code>","text":"<p>Get the affine transformation matrix that transforms image coordinates of other into image coordinates of this image geometry.</p> <p>Defined only for grid mappings with rectified x,y coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>GridMapping</code> <p>The other image geometry</p> required <p>Returns:</p> Type Description <code>AffineTransformMatrix</code> <p>Affine transformation matrix</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>def ij_transform_to(self, other: \"GridMapping\") -&gt; AffineTransformMatrix:\n    \"\"\"Get the affine transformation matrix that transforms\n    image coordinates of *other* into image coordinates\n    of this image geometry.\n\n    Defined only for grid mappings with rectified x,y coordinates.\n\n    Args:\n        other: The other image geometry\n\n    Returns:\n        Affine transformation matrix\n    \"\"\"\n    self._assert_regular()\n    self.assert_regular(other, name=\"other\")\n    a = _to_affine(self.ij_to_xy_transform)\n    b = _to_affine(other.xy_to_ij_transform)\n    return _from_affine(b * a)\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.ij_transform_from","title":"<code>ij_transform_from(other)</code>","text":"<p>Get the affine transformation matrix that transforms image coordinates of this image geometry to image coordinates of other.</p> <p>Defined only for grid mappings with rectified x,y coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>GridMapping</code> <p>The other image geometry</p> required <p>Returns:</p> Type Description <code>AffineTransformMatrix</code> <p>Affine transformation matrix</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>def ij_transform_from(self, other: \"GridMapping\") -&gt; AffineTransformMatrix:\n    \"\"\"Get the affine transformation matrix that transforms\n    image coordinates of this image geometry to image\n    coordinates of *other*.\n\n    Defined only for grid mappings with rectified x,y coordinates.\n\n    Args:\n        other: The other image geometry\n\n    Returns:\n        Affine transformation matrix\n    \"\"\"\n    self._assert_regular()\n    self.assert_regular(other, name=\"other\")\n    a = _to_affine(self.ij_transform_to(other))\n    return _from_affine(~a)\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.ij_bbox_from_xy_bbox","title":"<code>ij_bbox_from_xy_bbox(xy_bbox, xy_border=0.0, ij_border=0)</code>","text":"<p>Compute bounding box in i,j pixel coordinates given a bounding box xy_bbox in x,y coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xy_bbox</code> <code>tuple[float, float, float, float]</code> <p>Box (x_min, y_min, x_max, y_max) given in the same CS as x and y.</p> required <code>xy_border</code> <code>float</code> <p>If non-zero, grows the bounding box xy_bbox before using it for comparisons. Defaults to 0.</p> <code>0.0</code> <code>ij_border</code> <code>int</code> <p>If non-zero, grows the returned i,j bounding box and clips it to size. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>int</code> <p>Bounding box in (i_min, j_min, i_max, j_max) in pixel</p> <code>int</code> <p>coordinates. Returns <code>(-1, -1, -1, -1)</code> if xy_bbox isn't</p> <code>int</code> <p>intersecting any of the x,y coordinates.</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>def ij_bbox_from_xy_bbox(\n    self,\n    xy_bbox: tuple[float, float, float, float],\n    xy_border: float = 0.0,\n    ij_border: int = 0,\n) -&gt; tuple[int, int, int, int]:\n    \"\"\"Compute bounding box in i,j pixel coordinates given a\n    bounding box *xy_bbox* in x,y coordinates.\n\n    Args:\n        xy_bbox: Box (x_min, y_min, x_max, y_max) given in the same\n            CS as x and y.\n        xy_border: If non-zero, grows the bounding box *xy_bbox*\n            before using it for comparisons. Defaults to 0.\n        ij_border: If non-zero, grows the returned i,j bounding box\n            and clips it to size. Defaults to 0.\n\n    Returns:\n        Bounding box in (i_min, j_min, i_max, j_max) in pixel\n        coordinates. Returns ``(-1, -1, -1, -1)`` if *xy_bbox* isn't\n        intersecting any of the x,y coordinates.\n    \"\"\"\n    xy_bboxes = np.array([xy_bbox], dtype=np.float64)\n    ij_bboxes = np.full_like(xy_bboxes, -1, dtype=np.int64)\n    self.ij_bboxes_from_xy_bboxes(\n        xy_bboxes, xy_border=xy_border, ij_border=ij_border, ij_bboxes=ij_bboxes\n    )\n    # noinspection PyTypeChecker\n    return tuple(map(int, ij_bboxes[0]))\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.ij_bboxes_from_xy_bboxes","title":"<code>ij_bboxes_from_xy_bboxes(xy_bboxes, xy_border=0.0, ij_border=0, ij_bboxes=None)</code>","text":"<p>Compute bounding boxes in pixel coordinates given bounding boxes xy_bboxes [[x_min, y_min, x_max, y_max], ...] in x,y coordinates.</p> <p>The returned array in i,j pixel coordinates has the same shape as xy_bboxes. The value ranges in the returned array [[i_min, j_min, i_max, j_max], ..]] are:</p> <ul> <li>i_min from 0 to width-1, i_max from 1 to width;</li> <li>j_min from 0 to height-1, j_max from 1 to height;</li> </ul> <p>so the i,j pixel coordinates can be used as array index slices.</p> <p>Parameters:</p> Name Type Description Default <code>xy_bboxes</code> <code>ndarray</code> <p>Numpy array of x,y bounding boxes [[x_min, y_min, x_max, y_max], ...] given in the same CS as x and y.</p> required <code>xy_border</code> <code>float</code> <p>If non-zero, grows the bounding box xy_bbox before using it for comparisons. Defaults to 0.</p> <code>0.0</code> <code>ij_border</code> <code>int</code> <p>If non-zero, grows the returned i,j bounding box and clips it to size. Defaults to 0.</p> <code>0</code> <code>ij_bboxes</code> <code>ndarray</code> <p>Numpy array of pixel i,j bounding boxes [[x_min, y_min, x_max, y_max], ...]. If given, must have same shape as xy_bboxes.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Bounding boxes in [[i_min, j_min, i_max, j_max], ..]] in</p> <code>ndarray</code> <p>pixel coordinates.</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>def ij_bboxes_from_xy_bboxes(\n    self,\n    xy_bboxes: np.ndarray,\n    xy_border: float = 0.0,\n    ij_border: int = 0,\n    ij_bboxes: np.ndarray = None,\n) -&gt; np.ndarray:\n    \"\"\"Compute bounding boxes in pixel coordinates given bounding boxes\n    *xy_bboxes* [[x_min, y_min, x_max, y_max], ...] in x,y coordinates.\n\n    The returned array in i,j pixel coordinates\n    has the same shape as *xy_bboxes*. The value ranges in the\n    returned array [[i_min, j_min, i_max, j_max], ..]] are:\n\n    * i_min from 0 to width-1, i_max from 1 to width;\n    * j_min from 0 to height-1, j_max from 1 to height;\n\n    so the i,j pixel coordinates can be used as array index slices.\n\n    Args:\n        xy_bboxes: Numpy array of x,y bounding boxes [[x_min, y_min,\n            x_max, y_max], ...] given in the same CS as x and y.\n        xy_border: If non-zero, grows the bounding box *xy_bbox*\n            before using it for comparisons. Defaults to 0.\n        ij_border: If non-zero, grows the returned i,j bounding box\n            and clips it to size. Defaults to 0.\n        ij_bboxes: Numpy array of pixel i,j bounding boxes [[x_min,\n            y_min, x_max, y_max], ...]. If given, must have same\n            shape as *xy_bboxes*.\n\n    Returns:\n        Bounding boxes in [[i_min, j_min, i_max, j_max], ..]] in\n        pixel coordinates.\n    \"\"\"\n    if ij_bboxes is None:\n        ij_bboxes = np.full_like(xy_bboxes, -1, dtype=np.int64)\n    else:\n        ij_bboxes[:, :] = -1\n    xy_coords = self.xy_coords\n    return self._compute_ij_bboxes_dask(\n        xy_coords[0], xy_coords[1], xy_bboxes, xy_border, ij_border, ij_bboxes\n    )\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.to_dataset_attrs","title":"<code>to_dataset_attrs()</code>","text":"<p>Get spatial dataset attributes as recommended by https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3#Recommended</p> <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>dictionary with dataset coordinate attributes.</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>def to_dataset_attrs(self) -&gt; Mapping[str, Any]:\n    \"\"\"Get spatial dataset attributes as recommended by\n    https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3#Recommended\n\n    Returns:\n        dictionary with dataset coordinate attributes.\n    \"\"\"\n\n    x1, y1, x2, y2 = self.xy_bbox\n\n    if self.crs.is_geographic:\n        lon_min, lat_min, lon_max, lat_max = self.xy_bbox\n        lon_res, lat_res = self.xy_res\n    else:\n        x_res, y_res = self.xy_res\n        # center position\n        xm1 = (x1 + x2) / 2\n        ym1 = (y1 + y2) / 2\n        # center position + delta\n        xm2 = xm1 + x_res\n        ym2 = ym1 + y_res\n        transformer = pyproj.Transformer.from_crs(\n            crs_from=self.crs, crs_to=CRS_CRS84\n        )\n        xx, yy = transformer.transform((x1, x2, xm1, xm2), (y1, y2, ym1, ym2))\n        lon_min, lon_max, lon_m1, lon_m2 = xx\n        lat_min, lat_max, lat_m1, lat_m2 = yy\n        # Estimate resolution (note, this may be VERY wrong)\n        lon_res = abs(lon_m2 - lon_m1)\n        lat_res = abs(lat_m2 - lat_m1)\n\n    geospatial_bounds_crs = \"CRS84\"\n    geospatial_bounds = (\n        f\"POLYGON((\"\n        f\"{lon_min} {lat_min}, \"\n        f\"{lon_min} {lat_max}, \"\n        f\"{lon_max} {lat_max}, \"\n        f\"{lon_max} {lat_min}, \"\n        f\"{lon_min} {lat_min}\"\n        f\"))\"\n    )\n\n    return dict(\n        geospatial_lon_units=\"degrees_east\",\n        geospatial_lon_min=lon_min,\n        geospatial_lon_max=lon_max,\n        geospatial_lon_resolution=lon_res,\n        geospatial_lat_units=\"degrees_north\",\n        geospatial_lat_min=lat_min,\n        geospatial_lat_max=lat_max,\n        geospatial_lat_resolution=lat_res,\n        geospatial_bounds_crs=geospatial_bounds_crs,\n        geospatial_bounds=geospatial_bounds,\n    )\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.to_coords","title":"<code>to_coords(xy_var_names=None, xy_dim_names=None, exclude_bounds=False, reuse_coords=False)</code>","text":"<p>Get CF-compliant axis coordinate variables and cell boundary coordinate variables.</p> <p>Defined only for grid mappings with regular x,y coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>xy_var_names</code> <code>tuple[str, str]</code> <p>Optional coordinate variable names (x_var_name, y_var_name).</p> <code>None</code> <code>xy_dim_names</code> <code>tuple[str, str]</code> <p>Optional coordinate dimensions names (x_dim_name, y_dim_name).</p> <code>None</code> <code>exclude_bounds</code> <code>bool</code> <p>If True, do not create bounds coordinates. Defaults to False.</p> <code>False</code> <code>reuse_coords</code> <code>bool</code> <p>Whether to either reuse target coordinate arrays from target_gm or to compute new ones.</p> <code>False</code> <p>Returns:</p> Type Description <code>Mapping[str, DataArray]</code> <p>dictionary with coordinate variables</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>def to_coords(\n    self,\n    xy_var_names: tuple[str, str] = None,\n    xy_dim_names: tuple[str, str] = None,\n    exclude_bounds: bool = False,\n    reuse_coords: bool = False,\n) -&gt; Mapping[str, xr.DataArray]:\n    \"\"\"Get CF-compliant axis coordinate variables and cell boundary\n    coordinate variables.\n\n    Defined only for grid mappings with regular x,y coordinates.\n\n    Args:\n        xy_var_names: Optional coordinate variable names\n            (x_var_name, y_var_name).\n        xy_dim_names: Optional coordinate dimensions names\n            (x_dim_name, y_dim_name).\n        exclude_bounds: If True, do not create bounds coordinates.\n            Defaults to False.\n        reuse_coords: Whether to either reuse target coordinate\n            arrays from target_gm or to compute new ones.\n\n    Returns:\n        dictionary with coordinate variables\n    \"\"\"\n    self._assert_regular()\n    from .coords import grid_mapping_to_coords\n\n    return grid_mapping_to_coords(\n        self,\n        xy_var_names=xy_var_names,\n        xy_dim_names=xy_dim_names,\n        exclude_bounds=exclude_bounds,\n        reuse_coords=reuse_coords,\n    )\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.transform","title":"<code>transform(crs, *, xy_res=None, tile_size=None, xy_var_names=None, tolerance=DEFAULT_TOLERANCE)</code>","text":"<p>Transform this grid mapping so it uses the given spatial coordinate reference system into another crs.</p> <p>Parameters:</p> Name Type Description Default <code>crs</code> <code>str | CRS</code> <p>The new spatial coordinate reference system.</p> required <code>xy_res</code> <code>FloatInt | tuple[FloatInt, FloatInt]</code> <p>Optional resolution in x- and y-directions. If given, speeds up the method by avoiding time-consuming spatial resolution estimation.</p> <code>None</code> <code>tile_size</code> <code>int | tuple[int, int]</code> <p>Optional new tile size.</p> <code>None</code> <code>xy_var_names</code> <code>tuple[str, str]</code> <p>Optional new coordinate names.</p> <code>None</code> <code>tolerance</code> <code>float</code> <p>Absolute tolerance used when comparing coordinates with each other. Must be in the units of the crs and must be greater zero.</p> <code>DEFAULT_TOLERANCE</code> <p>Returns:</p> Type Description <code>GridMapping</code> <p>A new grid mapping that uses crs.</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>def transform(\n    self,\n    crs: str | pyproj.crs.CRS,\n    *,\n    xy_res: FloatInt | tuple[FloatInt, FloatInt] = None,\n    tile_size: int | tuple[int, int] = None,\n    xy_var_names: tuple[str, str] = None,\n    tolerance: float = DEFAULT_TOLERANCE,\n) -&gt; \"GridMapping\":\n    \"\"\"Transform this grid mapping so it uses the given\n    spatial coordinate reference system into another *crs*.\n\n    Args:\n        crs: The new spatial coordinate reference system.\n        xy_res: Optional resolution in x- and y-directions.\n            If given, speeds up the method by avoiding time-consuming\n            spatial resolution estimation.\n        tile_size: Optional new tile size.\n        xy_var_names: Optional new coordinate names.\n        tolerance: Absolute tolerance used when comparing\n            coordinates with each other. Must be in the units of the\n            *crs* and must be greater zero.\n\n    Returns:\n        A new grid mapping that uses *crs*.\n    \"\"\"\n    from .transform import transform_grid_mapping\n\n    return transform_grid_mapping(\n        self,\n        crs,\n        xy_res=xy_res,\n        tile_size=tile_size,\n        xy_var_names=xy_var_names,\n        tolerance=tolerance,\n    )\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.regular","title":"<code>regular(size, xy_min, xy_res, crs, *, tile_size=None, is_j_axis_up=False)</code>  <code>classmethod</code>","text":"<p>Create a new regular grid mapping.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int | tuple[int, int]</code> <p>Size in pixels.</p> required <code>xy_min</code> <code>tuple[float, float]</code> <p>Minimum x- and y-coordinates.</p> required <code>xy_res</code> <code>float | tuple[float, float]</code> <p>Resolution in x- and y-directions.</p> required <code>crs</code> <code>str | CRS</code> <p>Spatial coordinate reference system.</p> required <code>tile_size</code> <code>int | tuple[int, int]</code> <p>Optional tile size.</p> <code>None</code> <code>is_j_axis_up</code> <code>bool</code> <p>Whether positive j-axis points up. Defaults to false.</p> <code>False</code> <p>Returns:</p> Type Description <code>GridMapping</code> <p>A new regular grid mapping.</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>@classmethod\ndef regular(\n    cls,\n    size: int | tuple[int, int],\n    xy_min: tuple[float, float],\n    xy_res: float | tuple[float, float],\n    crs: str | pyproj.crs.CRS,\n    *,\n    tile_size: int | tuple[int, int] = None,\n    is_j_axis_up: bool = False,\n) -&gt; \"GridMapping\":\n    \"\"\"Create a new regular grid mapping.\n\n    Args:\n        size: Size in pixels.\n        xy_min: Minimum x- and y-coordinates.\n        xy_res: Resolution in x- and y-directions.\n        crs: Spatial coordinate reference system.\n        tile_size: Optional tile size.\n        is_j_axis_up: Whether positive j-axis points up. Defaults to\n            false.\n\n    Returns:\n        A new regular grid mapping.\n    \"\"\"\n    from .regular import new_regular_grid_mapping\n\n    return new_regular_grid_mapping(\n        size=size,\n        xy_min=xy_min,\n        xy_res=xy_res,\n        crs=crs,\n        tile_size=tile_size,\n        is_j_axis_up=is_j_axis_up,\n    )\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.to_regular","title":"<code>to_regular(tile_size=None, is_j_axis_up=False)</code>","text":"<p>Transform this grid mapping into one that is regular.</p> <p>Parameters:</p> Name Type Description Default <code>tile_size</code> <code>int | tuple[int, int] | None</code> <p>Optional tile size.</p> <code>None</code> <code>is_j_axis_up</code> <code>bool</code> <p>Whether positive j-axis points up. Defaults to false.</p> <code>False</code> <p>Returns:</p> Type Description <code>GridMapping</code> <p>A new regular grid mapping or this grid mapping, if it is</p> <code>GridMapping</code> <p>already regular.</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>def to_regular(\n    self, tile_size: int | tuple[int, int] | None = None, is_j_axis_up: bool = False\n) -&gt; \"GridMapping\":\n    \"\"\"Transform this grid mapping into one that is regular.\n\n    Args:\n        tile_size: Optional tile size.\n        is_j_axis_up: Whether positive j-axis points up. Defaults to\n            false.\n\n    Returns:\n        A new regular grid mapping or this grid mapping, if it is\n        already regular.\n    \"\"\"\n    from .regular import to_regular_grid_mapping\n\n    return to_regular_grid_mapping(\n        self, tile_size=tile_size, is_j_axis_up=is_j_axis_up\n    )\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.from_dataset","title":"<code>from_dataset(dataset, *, crs=None, tile_size=None, prefer_is_regular=True, prefer_crs=None, emit_warnings=False, tolerance=DEFAULT_TOLERANCE)</code>  <code>classmethod</code>","text":"<p>Create a grid mapping for the given dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset</code> <p>The dataset.</p> required <code>crs</code> <code>str | CRS | None</code> <p>Optional spatial coordinate reference system.</p> <code>None</code> <code>tile_size</code> <code>int | tuple[int, int] | None</code> <p>Optional tile size</p> <code>None</code> <code>prefer_is_regular</code> <code>bool</code> <p>Whether to prefer a regular grid mapping if multiple found. Default is True.</p> <code>True</code> <code>prefer_crs</code> <code>str | CRS | None</code> <p>The preferred CRS of a grid mapping if multiple found.</p> <code>None</code> <code>emit_warnings</code> <code>bool</code> <p>Whether to emit warning for non-CF compliant datasets.</p> <code>False</code> <code>tolerance</code> <code>float</code> <p>Absolute tolerance used when comparing coordinates with each other. Must be in the units of the crs and must be greater zero.</p> <code>DEFAULT_TOLERANCE</code> <p>Returns:</p> Type Description <code>GridMapping</code> <p>a new grid mapping instance.</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>@classmethod\ndef from_dataset(\n    cls,\n    dataset: xr.Dataset,\n    *,\n    crs: str | pyproj.crs.CRS | None = None,\n    tile_size: int | tuple[int, int] | None = None,\n    prefer_is_regular: bool = True,\n    prefer_crs: str | pyproj.crs.CRS | None = None,\n    emit_warnings: bool = False,\n    tolerance: float = DEFAULT_TOLERANCE,\n) -&gt; \"GridMapping\":\n    \"\"\"Create a grid mapping for the given *dataset*.\n\n    Args:\n        dataset: The dataset.\n        crs: Optional spatial coordinate reference system.\n        tile_size: Optional tile size\n        prefer_is_regular: Whether to prefer a regular grid mapping\n            if multiple found. Default is True.\n        prefer_crs: The preferred CRS of a grid mapping if multiple\n            found.\n        emit_warnings: Whether to emit warning for non-CF compliant\n            datasets.\n        tolerance: Absolute tolerance used when comparing\n            coordinates with each other. Must be in the units of the\n            *crs* and must be greater zero.\n\n    Returns:\n        a new grid mapping instance.\n    \"\"\"\n    from .dataset import new_grid_mapping_from_dataset\n\n    return new_grid_mapping_from_dataset(\n        dataset=dataset,\n        crs=crs,\n        tile_size=tile_size,\n        prefer_is_regular=prefer_is_regular,\n        prefer_crs=prefer_crs,\n        emit_warnings=emit_warnings,\n        tolerance=tolerance,\n    )\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.from_coords","title":"<code>from_coords(x_coords, y_coords, crs, *, tile_size=None, tolerance=DEFAULT_TOLERANCE)</code>  <code>classmethod</code>","text":"<p>Create a grid mapping from given x- and y-coordinates x_coords, y_coords and spatial coordinate reference system crs.</p> <p>Parameters:</p> Name Type Description Default <code>x_coords</code> <code>DataArray</code> <p>The x-coordinates.</p> required <code>y_coords</code> <code>DataArray</code> <p>The y-coordinates.</p> required <code>crs</code> <code>str | CRS</code> <p>The spatial coordinate reference system.</p> required <code>tile_size</code> <code>int | tuple[int, int] | None</code> <p>Optional tile size.</p> <code>None</code> <code>tolerance</code> <code>float</code> <p>Absolute tolerance used when comparing coordinates with each other. Must be in the units of the crs and must be greater zero.</p> <code>DEFAULT_TOLERANCE</code> <p>Returns:</p> Type Description <code>GridMapping</code> <p>A new grid mapping.</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>@classmethod\ndef from_coords(\n    cls,\n    x_coords: xr.DataArray,\n    y_coords: xr.DataArray,\n    crs: str | pyproj.crs.CRS,\n    *,\n    tile_size: int | tuple[int, int] | None = None,\n    tolerance: float = DEFAULT_TOLERANCE,\n) -&gt; \"GridMapping\":\n    \"\"\"Create a grid mapping from given x- and y-coordinates\n    *x_coords*, *y_coords* and spatial coordinate reference\n    system *crs*.\n\n    Args:\n        x_coords: The x-coordinates.\n        y_coords: The y-coordinates.\n        crs: The spatial coordinate reference system.\n        tile_size: Optional tile size.\n        tolerance: Absolute tolerance used when comparing\n            coordinates with each other. Must be in the units of the\n            *crs* and must be greater zero.\n\n    Returns:\n        A new grid mapping.\n    \"\"\"\n    from .coords import new_grid_mapping_from_coords\n\n    return new_grid_mapping_from_coords(\n        x_coords=x_coords,\n        y_coords=y_coords,\n        crs=crs,\n        tile_size=tile_size,\n        tolerance=tolerance,\n    )\n</code></pre>"},{"location":"api/#xcube_resampling.gridmapping.GridMapping.is_close","title":"<code>is_close(other, tolerance=DEFAULT_TOLERANCE)</code>","text":"<p>Tests whether this grid mapping is close to other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>GridMapping</code> <p>The other grid mapping.</p> required <code>tolerance</code> <code>float</code> <p>Absolute tolerance used when comparing coordinates with each other. Must be in the units of the crs and must be greater zero.</p> <code>DEFAULT_TOLERANCE</code> <p>Returns:</p> Type Description <code>bool</code> <p>True, if so, False otherwise.</p> Source code in <code>xcube_resampling/gridmapping/base.py</code> <pre><code>def is_close(\n    self, other: \"GridMapping\", tolerance: float = DEFAULT_TOLERANCE\n) -&gt; bool:\n    \"\"\"Tests whether this grid mapping is close to *other*.\n\n    Args:\n        other: The other grid mapping.\n        tolerance: Absolute tolerance used when comparing\n            coordinates with each other. Must be in the units of the\n            *crs* and must be greater zero.\n\n    Returns:\n        True, if so, False otherwise.\n    \"\"\"\n    if self is other:\n        return True\n    if (\n        self.is_j_axis_up == other.is_j_axis_up\n        and self.is_lon_360 == other.is_lon_360\n        and self.is_regular == other.is_regular\n        and self.size == other.size\n        and self.tile_size == other.tile_size\n        and self.crs == other.crs\n    ):\n        sxr, syr = self.xy_res\n        oxr, oyr = other.xy_res\n        if math.isclose(sxr, oxr, abs_tol=tolerance) and math.isclose(\n            syr, oyr, abs_tol=tolerance\n        ):\n            sx1, sy1, sx2, sy2 = self.xy_bbox\n            ox1, oy1, ox2, oy2 = other.xy_bbox\n            return (\n                math.isclose(sx1, ox1, abs_tol=tolerance)\n                and math.isclose(sy1, oy1, abs_tol=tolerance)\n                and math.isclose(sx2, ox2, abs_tol=tolerance)\n                and math.isclose(sy2, oy2, abs_tol=tolerance)\n            )\n    return False\n</code></pre>"},{"location":"guide/","title":"User Guide for xcube-resampling","text":"<p>xcube-resampling provides algorithms for representing a dataset in a different grid mapping. It supports:</p> <ul> <li>Simple resampling via affine transformation  </li> <li>Reprojection between coordinate reference systems (CRS)  </li> <li>Rectification of non-regular grids to regular grids  </li> </ul> <p>All resampling methods are built around the <code>GridMapping</code> class, which represents a spatial grid mapping and contains all necessary information for resampling.  </p> <p>We first introduce the <code>GridMapping</code> class before explaining the three resampling algorithms.</p>"},{"location":"guide/#gridmapping-the-grid-mapping-object","title":"<code>GridMapping</code> \u2013 the grid mapping object","text":"<p>A <code>GridMapping</code> defines the spatial structure of a dataset. It follows the  CF conventions for grid mappings  and provides a standardized way to describe geospatial grids. It stores metadata such as the coordinate reference system (CRS), spatial resolution, bounding box, spatial dimensions, coordinates, and tile size (for chunked datasets).</p> <p>Grids can be defined in two ways:</p> <ul> <li>1D coordinates \u2013 regular grids defined by evenly spaced x/y or lat/lon axes.  </li> <li>2D coordinates \u2013 irregular grids where each pixel has its own pair of x/y or    lat/lon coordinates.</li> </ul>"},{"location":"guide/#creating-a-gridmapping-object","title":"Creating a <code>GridMapping</code> object","text":"<p>There are three main ways to create a <code>GridMapping</code> instance:</p>"},{"location":"guide/#1-regular-grid-mapping","title":"1. Regular grid mapping","text":"<p>Use <code>GridMapping.regular</code>:</p> <pre><code>from xcube_resampling.gridmapping import GridMapping\n\ngm = GridMapping.regular(size, xy_min, xy_res, crs)\n</code></pre> <p>Parameter descriptions can be found here.</p>"},{"location":"guide/#2-create-a-grid-mapping-from-an-existing-dataset","title":"2. Create a grid mapping from an existing dataset","text":"<p>Use the <code>GridMapping.from_dataset</code> method:</p> <p><pre><code>from xcube_resampling.gridmapping import GridMapping\n\ngm = GridMapping.from_dataset(ds)\n</code></pre> Here, <code>ds</code> is a <code>xarray.Dataset</code>. Further optional parameters can be found here.</p> <p>Note: If no grid mapping is provided for the input dataset, the resampling functions  use this method to derive one.</p>"},{"location":"guide/#3-create-a-grid-mapping-from-coordinates","title":"3. Create a grid mapping from coordinates","text":"<p>Use the <code>GridMapping.from_coords</code> method:</p> <p><pre><code>from xcube_resampling.gridmapping import GridMapping\n\ngm = GridMapping.from_coords(x_coords, y_coords, crs)\n</code></pre> Here, <code>x_coords</code> and <code>y_coords</code> are <code>xarray.Array</code> instances, and <code>crs</code> is the  coordinate reference system (CRS). Further details of the parameters can be found here.</p>"},{"location":"guide/#derive-new-gridmapping-instances","title":"Derive new <code>GridMapping</code> instances","text":"<p>You can create new grid mappings from existing ones using:</p> <ul> <li>derive:    change selected properties.</li> <li>scale:    create a scaled version of a regular grid mapping.</li> <li>to_regular:   convert an irregular grid mapping to a regular one.</li> <li>transform:   change the CRS of a grid mapping (regular \u2192 irregular with 2D coordinates).</li> </ul> <p>An example is available in the Example Notebooks.</p>"},{"location":"guide/#resampling-algorithms","title":"Resampling Algorithms","text":"<p>The function <code>resample_in_space</code> integrates all three resampling algorithms and automatically selects the most appropriate one:</p> Algorithm Function Selection Criteria Affine Transformation <code>affine_transform_dataset</code> Source and target grids are both regular and share the same CRS. Reprojection <code>reproject_dataset</code> Source and target grids are both regular but have different CRS. Rectification <code>rectify_dataset</code> Source grid is irregular with 2D coordinates. <p>With <code>resample_in_space</code>, users do not need to worry about selecting the right algorithm\u2014the function determines and applies it automatically.</p>"},{"location":"guide/#common-parameters-for-all-resampling-algorithms","title":"Common parameters for all resampling algorithms","text":"Parameter Type / Accepted Values Description Default <code>variables</code> <code>str</code> or iterable of <code>str</code> Name(s) of variables to resample. If <code>None</code>, all data variables are processed. <code>None</code> <code>interp_methods</code> <code>int</code>, <code>str</code>, or <code>dict</code> mapping var/dtype to method. Supported:\u2022 <code>0</code> \u2014 nearest neighbor\u2022 <code>1</code> \u2014 linear / bilinear\u2022 <code>\"nearest\"</code>\u2022 <code>\"triangular\"</code>\u2022 <code>\"bilinear\"</code> Interpolation method for upsampling spatial data variables. Can be a single value or per-variable/dtype mapping. <code>0</code> for integer arrays, else <code>1</code> <code>agg_methods</code> <code>str</code> or <code>dict</code> mapping var/dtype to method. Supported:<code>\"center\"</code>, <code>\"count\"</code>, <code>\"first\"</code>, <code>\"last\"</code>, <code>\"max\"</code>, <code>\"mean\"</code>, <code>\"median\"</code>, <code>\"mode\"</code>, <code>\"min\"</code>, <code>\"prod\"</code>, <code>\"std\"</code>, <code>\"sum\"</code>, <code>\"var\"</code> Aggregation method for downsampling spatial data variables. <code>\"center\"</code> for integer arrays, else <code>\"mean\"</code> <code>recover_nans</code> <code>bool</code> or <code>dict</code> mapping var/dtype to <code>bool</code> Enable NaN recovery during upsampling (only applies when interpolation method is not nearest). <code>False</code> <code>fill_values</code> scalar or <code>dict</code> mapping var/dtype to value. Fill value(s) for areas outside input coverage. \u2022 float \u2014 NaN\u2022 uint8 \u2014 255\u2022 uint16 \u2014 65535\u2022 other ints \u2014 -1"},{"location":"guide/#1-affine-transformation","title":"1. Affine Transformation","text":"<p>An affine transformation can be applied when both the source and target grid mappings are regular and share the same CRS. The function <code>affine_transform_dataset</code>  requires the input dataset and the target grid mapping.  </p> <p>For any data array in the dataset with two spatial dimensions as the last two axes, an affine transformation is performed using <code>dask_image.ndinterp.affine_transform</code>. The resulting dataset contains resampled data arrays aligned to the target grid mapping.  </p> <ul> <li>Data variables without spatial dimensions are copied to the output.  </li> <li>Variables with only one spatial dimension are ignored.  </li> </ul> <p>Note: The <code>interp_methods</code> parameter corresponds to the <code>order</code> parameter in <code>dask_image.ndinterp.affine_transform</code>. Only spline orders <code>[0, 1]</code> are supported to avoid unintended blending across non-spatial dimensions (e.g., time) in 3D arrays.  </p> <p>Simple examples of affine transformations are shown in the Example Notebook Affine Transformation.</p>"},{"location":"guide/#2-reprojection","title":"2. Reprojection","text":"<p>Reprojection can be applied when both source and target grid mappings are regular but use different CRSs. The function <code>reproject_dataset</code> requires the input dataset and the target grid mapping.  </p> <p>The procedure is as follows:</p> <ol> <li>Check if the target grid resolution is coarser than the source grid resolution.    If so, the source dataset is downsampled/aggregated using affine resampling.  </li> <li>Transform the target coordinates to the source CRS, producing 2D irregular    coordinates.  </li> <li>For each transformed irregular pixel location, identify sub-pixel values in    the regular source grid.  </li> <li>Perform the selected interpolation using these sub-pixel values.  </li> </ol> <p>Supported interpolation methods are described in Section Interpolation Methods.  </p> <p>A large-scale example is shown in the Example Notebooks.</p>"},{"location":"guide/#3-rectification","title":"3. Rectification","text":"<p>Rectification is used when the source dataset has an irregular grid. The function <code>rectify_dataset</code>  requires only the input dataset.  </p> <p>If no target grid mapping is provided, the source grid mapping is converted to a regular grid, and interpolation is performed so that the new dataset is defined on this regular grid.  </p> <p>The procedure is as follows:</p> <ol> <li>If the CRS differs, the 2D irregular source grid is transformed to the target    CRS, resulting in 2D coordinates in the target CRS.  </li> <li>If the target resolution is coarser than the source resolution, the source    dataset is downsampled/aggregated using affine resampling.  </li> <li>For each regular target grid point, determine the sub-pixel position in the    irregular (optionally transformed) source grid.  </li> </ol> <p>Note: Determining sub-pixel positions in an irregular grid is more computationally expensive than the reprojection algorithm, as the lookup grid is irregular. These positions determine the neighboring points used for the selected interpolation method.  </p> <p>Supported interpolation methods are described in Section Interpolation Methods.  </p> <p>An example notebook demonstrating Sentinel-3 scene rectification is available in the Example Notebooks.</p>"},{"location":"guide/#interpolation-methods","title":"Interpolation Methods","text":"<p>As mentioned in Section Reprojection and Section Rectification, two 2D coordinate images are generated, showing the subpixel fractions u, v of a target point with respect to the source grid points, as depicted in the following image:</p> <p></p> <p>This is the starting point for all three interpolation methods described below.</p>"},{"location":"guide/#nearest-neighbor-nearest-0","title":"Nearest Neighbor - <code>\"nearest\"</code>, <code>0</code>","text":"<p>The simplest case is a nearest neighbor lookup, which determines the pixel value V of point P in the target grid mapping according to:</p> <ul> <li>V = V1 if u &lt;= \u00bd and v &lt;= \u00bd </li> <li>V = V2 if u &gt; \u00bd and v &lt;= \u00bd </li> <li>V = V3 if u &lt;= \u00bd and v &gt; \u00bd </li> <li>V = V4 if u &gt; \u00bd and v &gt; \u00bd </li> </ul> <p>where V1, V2, V3, V4 are the pixel values of the corresponding points in the source dataset.  </p> <p>The interpolation is shown in the following image:</p> <p></p>"},{"location":"guide/#bilinear-bilinear-1","title":"Bilinear - <code>\"bilinear\"</code>, <code>1</code>","text":"<p>Bilinear interpolation uses the four adjacent source pixels to compute the value V of point P in the target grid mapping according to:</p> <p>V = VA + v (VB \u2212 VA) </p> <p>with  </p> <p>VA = V1 + u (V2 \u2212 V1) VB = V3 + u (V4 \u2212 V3) </p> <p>where V1, V2, V3, V4 are the pixel values of the corresponding points in the source dataset.</p>"},{"location":"guide/#triangular-triangular","title":"Triangular - <code>\"triangular\"</code>","text":"<p>The triangluar interpolation can be used to speed up the bilinear interpolation. It  uses three adjacent source pixels to determine the pixel value V of point P in  the target grid mapping according to:</p> <ul> <li>V = V1 + u (V2 \u2212 V1) + v (V3 \u2212 V1), if u+v &lt; 1 </li> <li>V = V4 + (1 - u) (V3 \u2212 V4) + (1 - v) (V2 \u2212 V4), if u+v &gt;= 1 </li> </ul> <p>where V1, V2, V3, V4 are the pixel values of the points in the source dataset.</p>"},{"location":"guide/#remarks","title":"Remarks","text":"<ol> <li>If the target pixel size is much smaller than the source pixel size, and the    source has low spatial resolution, results may be inaccurate. Curved source pixel    boundaries must be considered for many projections.</li> <li>If x, y are decimal longitude and latitude, and the north or south poles are in    the scene, the algorithm may fail. Workarounds include:<ul> <li>Transforming source coordinates into another suitable CRS first.  </li> <li>Transforming longitude values x into complex numbers and normalizing latitudes   y to the range [-1, +1]:  <pre><code>x' = cos(x) + i sin(x)  \ny' = 2y / \u03c0\n</code></pre> </li> </ul> </li> </ol>"},{"location":"start/","title":"Getting Started","text":"<p>The <code>xcube-resampling</code> package can be installed into an existing Python environment using</p> <pre><code>pip install xcube-resampling\n</code></pre> <p>or</p> <pre><code>conda install -c conda-forge xcube-resampling\n</code></pre> <p>After installation, you are ready to go and use <code>resample_in_space</code> to resample you datasets: </p>"},{"location":"start/#generate-a-sample-dataset","title":"Generate a sample dataset","text":"<pre><code>import numpy as np\nimport xarray as xr\n\nres = 0.1\nsource_ds = xr.Dataset(\n    data_vars=dict(\n        refl=xr.DataArray(\n            np.array(\n                [\n                    [0, 1, 0, 2, 0, 3, 0, 4],\n                    [2, 0, 3, 0, 4, 0, 1, 0],\n                    [0, 4, 0, 1, 0, 2, 0, 3],\n                    [1, 0, 2, 0, 3, 0, 4, 0],\n                    [0, 3, 0, 4, 0, 1, 0, 2],\n                    [4, 0, 1, 0, 2, 0, 3, 0],\n                ],\n                dtype=np.float64,\n            ),\n            dims=(\"lat\", \"lon\"),\n        )\n    ),\n    coords=dict(\n        lon=xr.DataArray(50.0 + res * np.arange(0, 8) + 0.5 * res, dims=\"lon\"),\n        lat=xr.DataArray(10.6 - res * np.arange(0, 6) - 0.5 * res, dims=\"lat\"),\n    ),\n)\n</code></pre>"},{"location":"start/#apply-resampling","title":"Apply resampling","text":"<pre><code>from xcube_resampling.spatial import resample_in_space\nfrom xcube_resampling.gridmapping import GridMapping\n\ntarget_gm = GridMapping.regular((3, 3), (50.05, 10.05), 0.2, \"EPSG:4326\")\ntarget_ds = resample_in_space(source_ds, target_gm=target_gm)\n</code></pre> <pre><code>&lt;xarray.Dataset&gt; Size: 128B\nDimensions:      (lat: 3, lon: 3)\nCoordinates:\n    spatial_ref  int64 8B 0\n  * lon          (lon) float64 24B 50.15 50.35 50.55\n  * lat          (lat) float64 24B 10.55 10.35 10.15\nData variables:\n    refl         (lat, lon) float64 72B 0.875 1.375 1.375 1.5 ... 1.25 1.5 1.0\n</code></pre>"},{"location":"examples/affine/","title":"Affine Transformation","text":"In\u00a0[1]: Copied! <pre>import xarray as xr\nimport numpy as np\nfrom xcube_resampling.affine import affine_transform_dataset\nfrom xcube_resampling.gridmapping import GridMapping\n</pre> import xarray as xr import numpy as np from xcube_resampling.affine import affine_transform_dataset from xcube_resampling.gridmapping import GridMapping In\u00a0[2]: Copied! <pre>def imshow(var):\n    var.plot.imshow(vmin=0, vmax=4)\n</pre> def imshow(var):     var.plot.imshow(vmin=0, vmax=4) In\u00a0[3]: Copied! <pre>res = 0.1\nsource_ds = xr.Dataset(\n    data_vars=dict(\n        refl=xr.DataArray(\n            np.array(\n                [\n                    [0, 1, 0, 2, 0, 3, 0, 4],\n                    [2, 0, 3, 0, 4, 0, 1, 0],\n                    [0, 4, 0, 1, 0, 2, 0, 3],\n                    [1, 0, 2, 0, 3, 0, 4, 0],\n                    [0, 3, 0, 4, 0, 1, 0, 2],\n                    [4, 0, 1, 0, 2, 0, 3, 0],\n                ],\n                dtype=np.float64,\n            ),\n            dims=(\"lat\", \"lon\"),\n        )\n    ),\n    coords=dict(\n        lon=xr.DataArray(50.0 + res * np.arange(0, 8) + 0.5 * res, dims=\"lon\"),\n        lat=xr.DataArray(10.6 - res * np.arange(0, 6) - 0.5 * res, dims=\"lat\"),\n    ),\n)\nsource_ds\n</pre> res = 0.1 source_ds = xr.Dataset(     data_vars=dict(         refl=xr.DataArray(             np.array(                 [                     [0, 1, 0, 2, 0, 3, 0, 4],                     [2, 0, 3, 0, 4, 0, 1, 0],                     [0, 4, 0, 1, 0, 2, 0, 3],                     [1, 0, 2, 0, 3, 0, 4, 0],                     [0, 3, 0, 4, 0, 1, 0, 2],                     [4, 0, 1, 0, 2, 0, 3, 0],                 ],                 dtype=np.float64,             ),             dims=(\"lat\", \"lon\"),         )     ),     coords=dict(         lon=xr.DataArray(50.0 + res * np.arange(0, 8) + 0.5 * res, dims=\"lon\"),         lat=xr.DataArray(10.6 - res * np.arange(0, 6) - 0.5 * res, dims=\"lat\"),     ), ) source_ds Out[3]: <pre>&lt;xarray.Dataset&gt; Size: 496B\nDimensions:  (lon: 8, lat: 6)\nCoordinates:\n  * lon      (lon) float64 64B 50.05 50.15 50.25 50.35 50.45 50.55 50.65 50.75\n  * lat      (lat) float64 48B 10.55 10.45 10.35 10.25 10.15 10.05\nData variables:\n    refl     (lat, lon) float64 384B 0.0 1.0 0.0 2.0 0.0 ... 0.0 2.0 0.0 3.0 0.0</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>lon: 8</li><li>lat: 6</li></ul></li><li>Coordinates: (2)<ul><li>lon(lon)float6450.05 50.15 50.25 ... 50.65 50.75<pre>array([50.05, 50.15, 50.25, 50.35, 50.45, 50.55, 50.65, 50.75])</pre></li><li>lat(lat)float6410.55 10.45 10.35 10.25 10.15 10.05<pre>array([10.55, 10.45, 10.35, 10.25, 10.15, 10.05])</pre></li></ul></li><li>Data variables: (1)<ul><li>refl(lat, lon)float640.0 1.0 0.0 2.0 ... 2.0 0.0 3.0 0.0<pre>array([[0., 1., 0., 2., 0., 3., 0., 4.],\n       [2., 0., 3., 0., 4., 0., 1., 0.],\n       [0., 4., 0., 1., 0., 2., 0., 3.],\n       [1., 0., 2., 0., 3., 0., 4., 0.],\n       [0., 3., 0., 4., 0., 1., 0., 2.],\n       [4., 0., 1., 0., 2., 0., 3., 0.]])</pre></li></ul></li><li>Indexes: (2)<ul><li>lonPandasIndex<pre>PandasIndex(Index([             50.05,              50.15,              50.25,\n       50.349999999999994, 50.449999999999996,              50.55,\n                    50.65,              50.75],\n      dtype='float64', name='lon'))</pre></li><li>latPandasIndex<pre>PandasIndex(Index([10.549999999999999,              10.45,              10.35,\n       10.249999999999998, 10.149999999999999, 10.049999999999999],\n      dtype='float64', name='lat'))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[4]: Copied! <pre>imshow(source_ds.refl)\n</pre> imshow(source_ds.refl) In\u00a0[5]: Copied! <pre>source_gm = GridMapping.from_dataset(source_ds)\nsource_gm.xy_bbox, source_gm.xy_res\n</pre> source_gm = GridMapping.from_dataset(source_ds) source_gm.xy_bbox, source_gm.xy_res Out[5]: <pre>((50, 10, 50.8, 10.6), (0.1, 0.1))</pre> In\u00a0[6]: Copied! <pre>target_gm = GridMapping.regular((3, 3), (50, 10), 0.1, source_gm.crs)\n# target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform\ntarget_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=1)\nimshow(target_ds.refl)\n</pre> target_gm = GridMapping.regular((3, 3), (50, 10), 0.1, source_gm.crs) # target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform target_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=1) imshow(target_ds.refl) In\u00a0[7]: Copied! <pre>target_gm = GridMapping.regular((3, 3), (50.05, 10.05), 0.1, source_gm.crs)\n# target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform\ntarget_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=\"bilinear\")\nimshow(target_ds.refl)\n</pre> target_gm = GridMapping.regular((3, 3), (50.05, 10.05), 0.1, source_gm.crs) # target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform target_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=\"bilinear\") imshow(target_ds.refl) In\u00a0[8]: Copied! <pre>target_gm = GridMapping.regular((8, 6), (50.05, 10.05), 0.1, source_gm.crs)\n# target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform\ntarget_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=dict(refl= 1))\nimshow(target_ds.refl)\n</pre> target_gm = GridMapping.regular((8, 6), (50.05, 10.05), 0.1, source_gm.crs) # target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform target_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=dict(refl= 1)) imshow(target_ds.refl) In\u00a0[9]: Copied! <pre>target_gm = GridMapping.regular((8, 6), (50.2, 10.1), 0.1, source_gm.crs)\n# target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform\ntarget_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=dict(refl=\"bilinear\"))\nimshow(target_ds.refl)\n</pre> target_gm = GridMapping.regular((8, 6), (50.2, 10.1), 0.1, source_gm.crs) # target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform target_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=dict(refl=\"bilinear\")) imshow(target_ds.refl) In\u00a0[10]: Copied! <pre>target_gm = GridMapping.regular((8, 6), (49.8, 9.9), 0.1, source_gm.crs)\n# target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform\ntarget_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=1)\nimshow(target_ds.refl)\n</pre> target_gm = GridMapping.regular((8, 6), (49.8, 9.9), 0.1, source_gm.crs) # target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform target_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=1) imshow(target_ds.refl) In\u00a0[11]: Copied! <pre>target_gm = GridMapping.regular((8, 6), (50, 10), 0.2, source_gm.crs)\n# target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform\ntarget_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=1)\nimshow(target_ds.refl)\n</pre> target_gm = GridMapping.regular((8, 6), (50, 10), 0.2, source_gm.crs) # target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform target_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=1) imshow(target_ds.refl) In\u00a0[12]: Copied! <pre>target_gm = GridMapping.regular((8, 6), (49.8, 9.8), 0.2, source_gm.crs)\n# target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform\ntarget_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=1)\nimshow(target_ds.refl)\n</pre> target_gm = GridMapping.regular((8, 6), (49.8, 9.8), 0.2, source_gm.crs) # target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform target_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=1) imshow(target_ds.refl) In\u00a0[13]: Copied! <pre>target_gm = GridMapping.regular((16, 12), (50, 10), 0.05, source_gm.crs)\n# target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform\ntarget_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=1)\nimshow(target_ds.refl)\n</pre> target_gm = GridMapping.regular((16, 12), (50, 10), 0.05, source_gm.crs) # target_gm.ij_to_xy_transform, target_gm.xy_to_ij_transform target_ds = affine_transform_dataset(source_ds, target_gm, interp_methods=1) imshow(target_ds.refl)"},{"location":"examples/coords/","title":"GridMapping instance","text":"In\u00a0[1]: Copied! <pre>import dask.array as da\nimport numpy as np\nimport pyproj as pp\nimport xarray as xr\n</pre> import dask.array as da import numpy as np import pyproj as pp import xarray as xr In\u00a0[3]: Copied! <pre>ds = xr.open_zarr(\"./inputdata/S3-OLCI-L2A.zarr.zip\", consolidated=False)\nds\n</pre> ds = xr.open_zarr(\"./inputdata/S3-OLCI-L2A.zarr.zip\", consolidated=False) ds Out[3]: <pre>&lt;xarray.Dataset&gt; Size: 72MB\nDimensions:        (y: 1890, x: 1189)\nCoordinates:\n    lat            (y, x) float64 18MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    lon            (y, x) float64 18MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\nDimensions without coordinates: y, x\nData variables:\n    quality_flags  (y, x) uint32 9MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    rtoa_3         (y, x) float32 9MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    rtoa_6         (y, x) float32 9MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    rtoa_8         (y, x) float32 9MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\nAttributes:\n    Conventions:   CF-1.4\n    product_type:  C2RCC_OLCI\n    start_date:    04-JUL-2018 09:21:55.677316\n    stop_date:     04-JUL-2018 09:23:18.811790</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>y: 1890</li><li>x: 1189</li></ul></li><li>Coordinates: (2)<ul><li>lat(y, x)float64dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;long_name :latitude coordinatestandard_name :latitudeunits :degrees_north  Array   Chunk   Bytes   17.14 MiB   2.00 MiB   Shape   (1890, 1189)   (512, 512)   Dask graph   12 chunks in 2 graph layers   Data type   float64 numpy.ndarray  1189 1890 </li><li>lon(y, x)float64dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;long_name :longitude coordinatestandard_name :longitudeunits :degrees_east  Array   Chunk   Bytes   17.14 MiB   2.00 MiB   Shape   (1890, 1189)   (512, 512)   Dask graph   12 chunks in 2 graph layers   Data type   float64 numpy.ndarray  1189 1890 </li></ul></li><li>Data variables: (4)<ul><li>quality_flags(y, x)uint32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;flag_coding_name :quality_flagsflag_descriptions :flag_masks :[-2147483648, 1073741824, 536870912, 268435456, 134217728, 67108864, 33554432, 16777216, 8388608, 4194304, 2097152, 1048576, 524288, 262144, 131072, 65536, 32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]flag_meanings :land coastline fresh_inland_water tidal_region bright straylight_risk invalid cosmetic duplicated sun_glint_risk dubious saturated_Oa01 saturated_Oa02 saturated_Oa03 saturated_Oa04 saturated_Oa05 saturated_Oa06 saturated_Oa07 saturated_Oa08 saturated_Oa09 saturated_Oa10 saturated_Oa11 saturated_Oa12 saturated_Oa13 saturated_Oa14 saturated_Oa15 saturated_Oa16 saturated_Oa17 saturated_Oa18 saturated_Oa19 saturated_Oa20 saturated_Oa21long_name :Classification and quality flags  Array   Chunk   Bytes   8.57 MiB   1.00 MiB   Shape   (1890, 1189)   (512, 512)   Dask graph   12 chunks in 2 graph layers   Data type   uint32 numpy.ndarray  1189 1890 </li><li>rtoa_3(y, x)float32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :2.0units :1wavelength :442.5  Array   Chunk   Bytes   8.57 MiB   1.00 MiB   Shape   (1890, 1189)   (512, 512)   Dask graph   12 chunks in 2 graph layers   Data type   float32 numpy.ndarray  1189 1890 </li><li>rtoa_6(y, x)float32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :5.0units :1wavelength :560.0  Array   Chunk   Bytes   8.57 MiB   1.00 MiB   Shape   (1890, 1189)   (512, 512)   Dask graph   12 chunks in 2 graph layers   Data type   float32 numpy.ndarray  1189 1890 </li><li>rtoa_8(y, x)float32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :7.0units :1wavelength :665.0  Array   Chunk   Bytes   8.57 MiB   1.00 MiB   Shape   (1890, 1189)   (512, 512)   Dask graph   12 chunks in 2 graph layers   Data type   float32 numpy.ndarray  1189 1890 </li></ul></li><li>Indexes: (0)<ul></ul></li><li>Attributes: (4)Conventions :CF-1.4product_type :C2RCC_OLCIstart_date :04-JUL-2018 09:21:55.677316stop_date :04-JUL-2018 09:23:18.811790</li></ul> In\u00a0[4]: Copied! <pre>crs_4326 = pp.crs.CRS(4326)\ncrs_4326\n</pre> crs_4326 = pp.crs.CRS(4326) crs_4326 Out[4]: <pre>&lt;Geographic 2D CRS: EPSG:4326&gt;\nName: WGS 84\nAxis Info [ellipsoidal]:\n- Lat[north]: Geodetic latitude (degree)\n- Lon[east]: Geodetic longitude (degree)\nArea of Use:\n- name: World.\n- bounds: (-180.0, -90.0, 180.0, 90.0)\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich</pre> In\u00a0[5]: Copied! <pre>crs_4326.is_geographic\n</pre> crs_4326.is_geographic Out[5]: <pre>True</pre> In\u00a0[6]: Copied! <pre>crs_4326.is_geocentric\n</pre> crs_4326.is_geocentric Out[6]: <pre>False</pre> In\u00a0[7]: Copied! <pre>crs_32633 = pp.crs.CRS(32633)\ncrs_32633\n</pre> crs_32633 = pp.crs.CRS(32633) crs_32633 Out[7]: <pre>&lt;Projected CRS: EPSG:32633&gt;\nName: WGS 84 / UTM zone 33N\nAxis Info [cartesian]:\n- E[east]: Easting (metre)\n- N[north]: Northing (metre)\nArea of Use:\n- name: Between 12\u00b0E and 18\u00b0E, northern hemisphere between equator and 84\u00b0N, onshore and offshore. Austria. Bosnia and Herzegovina. Cameroon. Central African Republic. Chad. Congo. Croatia. Czechia. Democratic Republic of the Congo (Zaire). Gabon. Germany. Hungary. Italy. Libya. Malta. Niger. Nigeria. Norway. Poland. San Marino. Slovakia. Slovenia. Svalbard. Sweden. Vatican City State.\n- bounds: (12.0, 0.0, 18.0, 84.0)\nCoordinate Operation:\n- name: UTM zone 33N\n- method: Transverse Mercator\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich</pre> In\u00a0[8]: Copied! <pre>t = pp.transformer.Transformer.from_crs(crs_4326, crs_32633)\nt\n</pre> t = pp.transformer.Transformer.from_crs(crs_4326, crs_32633) t Out[8]: <pre>&lt;Conversion Transformer: pipeline&gt;\nDescription: UTM zone 33N\nArea of Use:\n- name: Between 12\u00b0E and 18\u00b0E, northern hemisphere between equator and 84\u00b0N, onshore and offshore.\n- bounds: (12.0, 0.0, 18.0, 84.0)</pre> In\u00a0[9]: Copied! <pre>lon = ds.lon.values\nlat = ds.lat.values\n</pre> lon = ds.lon.values lat = ds.lat.values In\u00a0[10]: Copied! <pre>%%time\nx, y = t.transform(lat, lon)\n</pre> %%time x, y = t.transform(lat, lon) <pre>CPU times: user 454 ms, sys: 10.1 ms, total: 464 ms\nWall time: 463 ms\n</pre> In\u00a0[11]: Copied! <pre>x, y\n</pre> x, y Out[11]: <pre>(array([[464353.17350437, 464753.99068697, 464753.99068697, ...,\n         778366.98327271, 778663.97989779, 778960.82095417],\n        [464300.61922255, 464697.86336861, 464697.86336861, ...,\n         778311.52553234, 778608.48730308, 778905.40483205],\n        [464244.50782782, 464643.5297553 , 464643.5297553 , ...,\n         778256.11946402, 778553.04638088, 778849.92904976],\n        ...,\n        [355582.31759961, 356009.5675282 , 356009.5675282 , ...,\n         668917.33742756, 669212.77356855, 669508.22326567],\n        [355522.80213548, 355950.07579013, 355950.07579013, ...,\n         668857.14267177, 669152.60061632, 669448.00001141],\n        [355463.34306198, 355890.64413473, 355890.64413473, ...,\n         668796.87484134, 669092.350345  , 669387.77154332]],\n       shape=(1890, 1189)),\n array([[6722665.0879521 , 6722587.51099095, 6722587.51099095, ...,\n         6662383.08675777, 6662325.42149084, 6662267.76727586],\n        [6722380.12777498, 6722303.24876914, 6722303.24876914, ...,\n         6662095.72015417, 6662038.04563426, 6661980.39060315],\n        [6722095.87204537, 6722018.63563135, 6722018.63563135, ...,\n         6661808.24764388, 6661750.56387706, 6661692.89959194],\n        ...,\n        [6186558.12992815, 6186468.08028835, 6186468.08028835, ...,\n         6120997.19266252, 6120934.81417697, 6120872.34396918],\n        [6186274.18860283, 6186184.02228292, 6186184.02228292, ...,\n         6120710.71380218, 6120648.21975818, 6120585.85404474],\n        [6185990.24598573, 6185900.07425244, 6185900.07425244, ...,\n         6120424.23357397, 6120361.73520792, 6120299.25393304]],\n       shape=(1890, 1189)))</pre> In\u00a0[12]: Copied! <pre>coords_4326 = da.stack([ds.lat.data, ds.lon.data]).rechunk((2, None, None))\ncoords_4326\n</pre> coords_4326 = da.stack([ds.lat.data, ds.lon.data]).rechunk((2, None, None)) coords_4326 Out[12]:  Array   Chunk   Bytes   34.29 MiB   4.00 MiB   Shape   (2, 1890, 1189)   (2, 512, 512)   Dask graph   12 chunks in 6 graph layers   Data type   float64 numpy.ndarray  1189 1890 2 In\u00a0[13]: Copied! <pre>def transform(block, t=None):\n    x1, y1 = block\n    x2, y2 = t.transform(x1, y1)\n    return np.stack([x2, y2])\n</pre> def transform(block, t=None):     x1, y1 = block     x2, y2 = t.transform(x1, y1)     return np.stack([x2, y2]) In\u00a0[14]: Copied! <pre>coords_32633 = da.apply_gufunc(\n    transform, \"()-&gt;()\", coords_4326, output_dtypes=np.float64, t=t\n)\ncoords_32633\n</pre> coords_32633 = da.apply_gufunc(     transform, \"()-&gt;()\", coords_4326, output_dtypes=np.float64, t=t ) coords_32633 Out[14]:  Array   Chunk   Bytes   34.29 MiB   4.00 MiB   Shape   (2, 1890, 1189)   (2, 512, 512)   Dask graph   12 chunks in 9 graph layers   Data type   float64 numpy.ndarray  1189 1890 2 In\u00a0[15]: Copied! <pre>%%time\nx, y = coords_32633.compute()\n</pre> %%time x, y = coords_32633.compute() <pre>CPU times: user 955 ms, sys: 107 ms, total: 1.06 s\nWall time: 343 ms\n</pre> In\u00a0[16]: Copied! <pre>x, y\n</pre> x, y Out[16]: <pre>(array([[464353.17350437, 464753.99068697, 464753.99068697, ...,\n         778366.98327271, 778663.97989779, 778960.82095417],\n        [464300.61922255, 464697.86336861, 464697.86336861, ...,\n         778311.52553234, 778608.48730308, 778905.40483205],\n        [464244.50782782, 464643.5297553 , 464643.5297553 , ...,\n         778256.11946402, 778553.04638088, 778849.92904976],\n        ...,\n        [355582.31759961, 356009.5675282 , 356009.5675282 , ...,\n         668917.33742756, 669212.77356855, 669508.22326567],\n        [355522.80213548, 355950.07579013, 355950.07579013, ...,\n         668857.14267177, 669152.60061632, 669448.00001141],\n        [355463.34306198, 355890.64413473, 355890.64413473, ...,\n         668796.87484134, 669092.350345  , 669387.77154332]],\n       shape=(1890, 1189)),\n array([[6722665.0879521 , 6722587.51099095, 6722587.51099095, ...,\n         6662383.08675777, 6662325.42149084, 6662267.76727586],\n        [6722380.12777498, 6722303.24876914, 6722303.24876914, ...,\n         6662095.72015417, 6662038.04563426, 6661980.39060315],\n        [6722095.87204537, 6722018.63563135, 6722018.63563135, ...,\n         6661808.24764388, 6661750.56387706, 6661692.89959194],\n        ...,\n        [6186558.12992815, 6186468.08028835, 6186468.08028835, ...,\n         6120997.19266252, 6120934.81417697, 6120872.34396918],\n        [6186274.18860283, 6186184.02228292, 6186184.02228292, ...,\n         6120710.71380218, 6120648.21975818, 6120585.85404474],\n        [6185990.24598573, 6185900.07425244, 6185900.07425244, ...,\n         6120424.23357397, 6120361.73520792, 6120299.25393304]],\n       shape=(1890, 1189)))</pre> In\u00a0[17]: Copied! <pre>def transform2(x1, y1, t=None):\n    x2, y2 = t.transform(x1, y1)\n    return x2, y2\n</pre> def transform2(x1, y1, t=None):     x2, y2 = t.transform(x1, y1)     return x2, y2 In\u00a0[18]: Copied! <pre>x, y = da.apply_gufunc(\n    transform2,\n    \"(),()-&gt;(),()\",\n    ds.lat.data,\n    ds.lon.data,\n    output_dtypes=(np.float64, np.float64),\n    t=t,\n)\nx, y\n</pre> x, y = da.apply_gufunc(     transform2,     \"(),()-&gt;(),()\",     ds.lat.data,     ds.lon.data,     output_dtypes=(np.float64, np.float64),     t=t, ) x, y Out[18]: <pre>(dask.array&lt;transpose, shape=(1890, 1189), dtype=float64, chunksize=(512, 512), chunktype=numpy.ndarray&gt;,\n dask.array&lt;transpose, shape=(1890, 1189), dtype=float64, chunksize=(512, 512), chunktype=numpy.ndarray&gt;)</pre> In\u00a0[19]: Copied! <pre>%%time\nxx = x.compute()\nyy = y.compute()\n</pre> %%time xx = x.compute() yy = y.compute() <pre>CPU times: user 1.69 s, sys: 64.8 ms, total: 1.76 s\nWall time: 570 ms\n</pre> In\u00a0[20]: Copied! <pre>xx, yy\n</pre> xx, yy Out[20]: <pre>(array([[464353.17350437, 464753.99068697, 464753.99068697, ...,\n         778366.98327271, 778663.97989779, 778960.82095417],\n        [464300.61922255, 464697.86336861, 464697.86336861, ...,\n         778311.52553234, 778608.48730308, 778905.40483205],\n        [464244.50782782, 464643.5297553 , 464643.5297553 , ...,\n         778256.11946402, 778553.04638088, 778849.92904976],\n        ...,\n        [355582.31759961, 356009.5675282 , 356009.5675282 , ...,\n         668917.33742756, 669212.77356855, 669508.22326567],\n        [355522.80213548, 355950.07579013, 355950.07579013, ...,\n         668857.14267177, 669152.60061632, 669448.00001141],\n        [355463.34306198, 355890.64413473, 355890.64413473, ...,\n         668796.87484134, 669092.350345  , 669387.77154332]],\n       shape=(1890, 1189)),\n array([[6722665.0879521 , 6722587.51099095, 6722587.51099095, ...,\n         6662383.08675777, 6662325.42149084, 6662267.76727586],\n        [6722380.12777498, 6722303.24876914, 6722303.24876914, ...,\n         6662095.72015417, 6662038.04563426, 6661980.39060315],\n        [6722095.87204537, 6722018.63563135, 6722018.63563135, ...,\n         6661808.24764388, 6661750.56387706, 6661692.89959194],\n        ...,\n        [6186558.12992815, 6186468.08028835, 6186468.08028835, ...,\n         6120997.19266252, 6120934.81417697, 6120872.34396918],\n        [6186274.18860283, 6186184.02228292, 6186184.02228292, ...,\n         6120710.71380218, 6120648.21975818, 6120585.85404474],\n        [6185990.24598573, 6185900.07425244, 6185900.07425244, ...,\n         6120424.23357397, 6120361.73520792, 6120299.25393304]],\n       shape=(1890, 1189)))</pre> In\u00a0[21]: Copied! <pre>pp.crs.CRS.from_string(\"urn:ogc:def:crs:OGC:1.3:CRS84\")\n</pre> pp.crs.CRS.from_string(\"urn:ogc:def:crs:OGC:1.3:CRS84\") Out[21]: <pre>&lt;Geographic 2D CRS: OGC:CRS84&gt;\nName: WGS 84 (CRS84)\nAxis Info [ellipsoidal]:\n- Lon[east]: Geodetic longitude (degree)\n- Lat[north]: Geodetic latitude (degree)\nArea of Use:\n- name: World.\n- bounds: (-180.0, -90.0, 180.0, 90.0)\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich</pre> In\u00a0[22]: Copied! <pre>pp.crs.CRS.from_user_input(\"epsg:4326\")\n</pre> pp.crs.CRS.from_user_input(\"epsg:4326\") Out[22]: <pre>&lt;Geographic 2D CRS: EPSG:4326&gt;\nName: WGS 84\nAxis Info [ellipsoidal]:\n- Lat[north]: Geodetic latitude (degree)\n- Lon[east]: Geodetic longitude (degree)\nArea of Use:\n- name: World.\n- bounds: (-180.0, -90.0, 180.0, 90.0)\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich</pre>"},{"location":"examples/rectify_sentinel3/","title":"Rectification to a Sentinel-3 OLCI scene","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nimport xarray as xr\nfrom xcube_resampling.rectify import rectify_dataset\n</pre> import matplotlib.pyplot as plt import numpy as np import xarray as xr from xcube_resampling.rectify import rectify_dataset In\u00a0[2]: Copied! <pre>%%time\nsource_ds = xr.open_zarr(\"./inputdata/S3-OLCI-L2A.zarr.zip\", consolidated=False)\nsource_ds\n</pre> %%time source_ds = xr.open_zarr(\"./inputdata/S3-OLCI-L2A.zarr.zip\", consolidated=False) source_ds <pre>CPU times: user 116 ms, sys: 15.9 ms, total: 132 ms\nWall time: 151 ms\n</pre> Out[2]: <pre>&lt;xarray.Dataset&gt; Size: 72MB\nDimensions:        (y: 1890, x: 1189)\nCoordinates:\n    lat            (y, x) float64 18MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    lon            (y, x) float64 18MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\nDimensions without coordinates: y, x\nData variables:\n    quality_flags  (y, x) uint32 9MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    rtoa_3         (y, x) float32 9MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    rtoa_6         (y, x) float32 9MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    rtoa_8         (y, x) float32 9MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\nAttributes:\n    Conventions:   CF-1.4\n    product_type:  C2RCC_OLCI\n    start_date:    04-JUL-2018 09:21:55.677316\n    stop_date:     04-JUL-2018 09:23:18.811790</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>y: 1890</li><li>x: 1189</li></ul></li><li>Coordinates: (2)<ul><li>lat(y, x)float64dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;long_name :latitude coordinatestandard_name :latitudeunits :degrees_north  Array   Chunk   Bytes   17.14 MiB   2.00 MiB   Shape   (1890, 1189)   (512, 512)   Dask graph   12 chunks in 2 graph layers   Data type   float64 numpy.ndarray  1189 1890 </li><li>lon(y, x)float64dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;long_name :longitude coordinatestandard_name :longitudeunits :degrees_east  Array   Chunk   Bytes   17.14 MiB   2.00 MiB   Shape   (1890, 1189)   (512, 512)   Dask graph   12 chunks in 2 graph layers   Data type   float64 numpy.ndarray  1189 1890 </li></ul></li><li>Data variables: (4)<ul><li>quality_flags(y, x)uint32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;flag_coding_name :quality_flagsflag_descriptions :flag_masks :[-2147483648, 1073741824, 536870912, 268435456, 134217728, 67108864, 33554432, 16777216, 8388608, 4194304, 2097152, 1048576, 524288, 262144, 131072, 65536, 32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]flag_meanings :land coastline fresh_inland_water tidal_region bright straylight_risk invalid cosmetic duplicated sun_glint_risk dubious saturated_Oa01 saturated_Oa02 saturated_Oa03 saturated_Oa04 saturated_Oa05 saturated_Oa06 saturated_Oa07 saturated_Oa08 saturated_Oa09 saturated_Oa10 saturated_Oa11 saturated_Oa12 saturated_Oa13 saturated_Oa14 saturated_Oa15 saturated_Oa16 saturated_Oa17 saturated_Oa18 saturated_Oa19 saturated_Oa20 saturated_Oa21long_name :Classification and quality flags  Array   Chunk   Bytes   8.57 MiB   1.00 MiB   Shape   (1890, 1189)   (512, 512)   Dask graph   12 chunks in 2 graph layers   Data type   uint32 numpy.ndarray  1189 1890 </li><li>rtoa_3(y, x)float32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :2.0units :1wavelength :442.5  Array   Chunk   Bytes   8.57 MiB   1.00 MiB   Shape   (1890, 1189)   (512, 512)   Dask graph   12 chunks in 2 graph layers   Data type   float32 numpy.ndarray  1189 1890 </li><li>rtoa_6(y, x)float32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :5.0units :1wavelength :560.0  Array   Chunk   Bytes   8.57 MiB   1.00 MiB   Shape   (1890, 1189)   (512, 512)   Dask graph   12 chunks in 2 graph layers   Data type   float32 numpy.ndarray  1189 1890 </li><li>rtoa_8(y, x)float32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :7.0units :1wavelength :665.0  Array   Chunk   Bytes   8.57 MiB   1.00 MiB   Shape   (1890, 1189)   (512, 512)   Dask graph   12 chunks in 2 graph layers   Data type   float32 numpy.ndarray  1189 1890 </li></ul></li><li>Indexes: (0)<ul></ul></li><li>Attributes: (4)Conventions :CF-1.4product_type :C2RCC_OLCIstart_date :04-JUL-2018 09:21:55.677316stop_date :04-JUL-2018 09:23:18.811790</li></ul> <p>The provided coordinates, latitude (<code>lat</code>) and longitude (<code>lon</code>), are terrain-corrected using a digital elevation model (DEM) that approximates the Earth's actual fractal surface. As a result, the gradient vectors do not vary monotonically across the scene. Instead, they reflect the surface roughness captured by the DEM. Areas of high terrain variability are highlighted in the right figure below.</p> In\u00a0[3]: Copied! <pre>%%time\nlon_grad = source_ds.lat.differentiate(\"y\").rename(\"Vertical Gradient\")\n\nfig, ax = plt.subplots(1, 2, figsize=(14, 5))\nsource_ds.rtoa_8.plot(ax=ax[0], cmap=\"gray\", vmax=0.2)\nlon_grad.plot(ax=ax[1], cmap=\"viridis\", robust=True)\n</pre> %%time lon_grad = source_ds.lat.differentiate(\"y\").rename(\"Vertical Gradient\")  fig, ax = plt.subplots(1, 2, figsize=(14, 5)) source_ds.rtoa_8.plot(ax=ax[0], cmap=\"gray\", vmax=0.2) lon_grad.plot(ax=ax[1], cmap=\"viridis\", robust=True) <pre>CPU times: user 893 ms, sys: 198 ms, total: 1.09 s\nWall time: 979 ms\n</pre> Out[3]: <pre>&lt;matplotlib.collections.QuadMesh at 0x760b10ebc910&gt;</pre> <p>Now, we can rectify the dataset. Note that this can be done with the <code>resample_in_space</code> method.</p> In\u00a0[4]: Copied! <pre>%%time\ntarget_ds = rectify_dataset(source_ds, interp_methods=\"nearest\")\ntarget_ds\n</pre> %%time target_ds = rectify_dataset(source_ds, interp_methods=\"nearest\") target_ds <pre>CPU times: user 2.42 s, sys: 165 ms, total: 2.59 s\nWall time: 1.38 s\n</pre> Out[4]: <pre>&lt;xarray.Dataset&gt; Size: 102MB\nDimensions:        (lon: 2926, lat: 2177)\nCoordinates:\n    spatial_ref    int64 8B 0\n  * lon            (lon) float64 23kB 12.69 12.7 12.7 12.7 ... 20.0 20.0 20.01\n  * lat            (lat) float64 17kB 60.64 60.64 60.64 ... 55.21 55.2 55.2\nData variables:\n    quality_flags  (lat, lon) uint32 25MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    rtoa_3         (lat, lon) float32 25MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    rtoa_6         (lat, lon) float32 25MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    rtoa_8         (lat, lon) float32 25MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\nAttributes:\n    Conventions:   CF-1.4\n    product_type:  C2RCC_OLCI\n    start_date:    04-JUL-2018 09:21:55.677316\n    stop_date:     04-JUL-2018 09:23:18.811790</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>lon: 2926</li><li>lat: 2177</li></ul></li><li>Coordinates: (3)<ul><li>spatial_ref()int640crs_wkt :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensemblegrid_mapping_name :latitude_longitude<pre>array(0)</pre></li><li>lon(lon)float6412.69 12.7 12.7 ... 20.0 20.0 20.01long_name :longitude coordinatestandard_name :longitudeunits :degrees_eastbounds :lon_bnds<pre>array([12.694301, 12.696801, 12.699301, ..., 20.001801, 20.004301, 20.006801],\n      shape=(2926,))</pre></li><li>lat(lat)float6460.64 60.64 60.64 ... 55.2 55.2long_name :latitude coordinatestandard_name :latitudeunits :degrees_northbounds :lat_bnds<pre>array([60.64018, 60.63768, 60.63518, ..., 55.20518, 55.20268, 55.20018],\n      shape=(2177,))</pre></li></ul></li><li>Data variables: (4)<ul><li>quality_flags(lat, lon)uint32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;flag_coding_name :quality_flagsflag_descriptions :flag_masks :[-2147483648, 1073741824, 536870912, 268435456, 134217728, 67108864, 33554432, 16777216, 8388608, 4194304, 2097152, 1048576, 524288, 262144, 131072, 65536, 32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]flag_meanings :land coastline fresh_inland_water tidal_region bright straylight_risk invalid cosmetic duplicated sun_glint_risk dubious saturated_Oa01 saturated_Oa02 saturated_Oa03 saturated_Oa04 saturated_Oa05 saturated_Oa06 saturated_Oa07 saturated_Oa08 saturated_Oa09 saturated_Oa10 saturated_Oa11 saturated_Oa12 saturated_Oa13 saturated_Oa14 saturated_Oa15 saturated_Oa16 saturated_Oa17 saturated_Oa18 saturated_Oa19 saturated_Oa20 saturated_Oa21long_name :Classification and quality flagsgrid_mapping :spatial_ref  Array   Chunk   Bytes   24.30 MiB   1.00 MiB   Shape   (2177, 2926)   (512, 512)   Dask graph   30 chunks in 40 graph layers   Data type   uint32 numpy.ndarray  2926 2177 </li><li>rtoa_3(lat, lon)float32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :2.0units :1wavelength :442.5grid_mapping :spatial_ref  Array   Chunk   Bytes   24.30 MiB   1.00 MiB   Shape   (2177, 2926)   (512, 512)   Dask graph   30 chunks in 40 graph layers   Data type   float32 numpy.ndarray  2926 2177 </li><li>rtoa_6(lat, lon)float32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :5.0units :1wavelength :560.0grid_mapping :spatial_ref  Array   Chunk   Bytes   24.30 MiB   1.00 MiB   Shape   (2177, 2926)   (512, 512)   Dask graph   30 chunks in 40 graph layers   Data type   float32 numpy.ndarray  2926 2177 </li><li>rtoa_8(lat, lon)float32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :7.0units :1wavelength :665.0grid_mapping :spatial_ref  Array   Chunk   Bytes   24.30 MiB   1.00 MiB   Shape   (2177, 2926)   (512, 512)   Dask graph   30 chunks in 40 graph layers   Data type   float32 numpy.ndarray  2926 2177 </li></ul></li><li>Indexes: (2)<ul><li>lonPandasIndex<pre>PandasIndex(Index([         12.694301, 12.696800999999999,          12.699301,\n                12.701801,          12.704301, 12.706800999999999,\n                12.709301,          12.711801, 12.714300999999999,\n                12.716801,\n       ...\n                19.984301,          19.986801, 19.989300999999998,\n                19.991801,          19.994301, 19.996800999999998,\n                19.999301,          20.001801, 20.004300999999998,\n                20.006801],\n      dtype='float64', name='lon', length=2926))</pre></li><li>latPandasIndex<pre>PandasIndex(Index([          60.64018,           60.63768,           60.63518,\n                 60.63268,           60.63018,           60.62768,\n                 60.62518,           60.62268,           60.62018,\n                 60.61768,\n       ...\n                 55.22268,           55.22018, 55.217679999999994,\n                 55.21518,           55.21268, 55.210179999999994,\n       55.207679999999996,           55.20518, 55.202679999999994,\n       55.200179999999996],\n      dtype='float64', name='lat', length=2177))</pre></li></ul></li><li>Attributes: (4)Conventions :CF-1.4product_type :C2RCC_OLCIstart_date :04-JUL-2018 09:21:55.677316stop_date :04-JUL-2018 09:23:18.811790</li></ul> In\u00a0[5]: Copied! <pre>%%time\ntarget_ds.rtoa_8.plot(cmap=\"gray\", vmax=0.2)\n</pre> %%time target_ds.rtoa_8.plot(cmap=\"gray\", vmax=0.2) <pre>CPU times: user 2.33 s, sys: 384 ms, total: 2.72 s\nWall time: 1.51 s\n</pre> Out[5]: <pre>&lt;matplotlib.collections.QuadMesh at 0x760b104c3ed0&gt;</pre> <p>You can also change the chunk size in the output dataset with the keyword argument <code>tile_size</code>. Note that <code>interp_methods=0</code> is identical to <code>interp_methods=\"nearest\"</code>.</p> In\u00a0[6]: Copied! <pre>%%time\ntarget_ds = rectify_dataset(source_ds, interp_methods=0, tile_size=2048)\ntarget_ds\n</pre> %%time target_ds = rectify_dataset(source_ds, interp_methods=0, tile_size=2048) target_ds <pre>CPU times: user 2.17 s, sys: 123 ms, total: 2.29 s\nWall time: 1.4 s\n</pre> Out[6]: <pre>&lt;xarray.Dataset&gt; Size: 102MB\nDimensions:        (lon: 2926, lat: 2177)\nCoordinates:\n    spatial_ref    int64 8B 0\n  * lon            (lon) float64 23kB 12.69 12.7 12.7 12.7 ... 20.0 20.0 20.01\n  * lat            (lat) float64 17kB 60.64 60.64 60.64 ... 55.21 55.2 55.2\nData variables:\n    quality_flags  (lat, lon) uint32 25MB dask.array&lt;chunksize=(2048, 2048), meta=np.ndarray&gt;\n    rtoa_3         (lat, lon) float32 25MB dask.array&lt;chunksize=(2048, 2048), meta=np.ndarray&gt;\n    rtoa_6         (lat, lon) float32 25MB dask.array&lt;chunksize=(2048, 2048), meta=np.ndarray&gt;\n    rtoa_8         (lat, lon) float32 25MB dask.array&lt;chunksize=(2048, 2048), meta=np.ndarray&gt;\nAttributes:\n    Conventions:   CF-1.4\n    product_type:  C2RCC_OLCI\n    start_date:    04-JUL-2018 09:21:55.677316\n    stop_date:     04-JUL-2018 09:23:18.811790</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>lon: 2926</li><li>lat: 2177</li></ul></li><li>Coordinates: (3)<ul><li>spatial_ref()int640crs_wkt :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensemblegrid_mapping_name :latitude_longitude<pre>array(0)</pre></li><li>lon(lon)float6412.69 12.7 12.7 ... 20.0 20.0 20.01long_name :longitude coordinatestandard_name :longitudeunits :degrees_eastbounds :lon_bnds<pre>array([12.694301, 12.696801, 12.699301, ..., 20.001801, 20.004301, 20.006801],\n      shape=(2926,))</pre></li><li>lat(lat)float6460.64 60.64 60.64 ... 55.2 55.2long_name :latitude coordinatestandard_name :latitudeunits :degrees_northbounds :lat_bnds<pre>array([60.64018, 60.63768, 60.63518, ..., 55.20518, 55.20268, 55.20018],\n      shape=(2177,))</pre></li></ul></li><li>Data variables: (4)<ul><li>quality_flags(lat, lon)uint32dask.array&lt;chunksize=(2048, 2048), meta=np.ndarray&gt;flag_coding_name :quality_flagsflag_descriptions :flag_masks :[-2147483648, 1073741824, 536870912, 268435456, 134217728, 67108864, 33554432, 16777216, 8388608, 4194304, 2097152, 1048576, 524288, 262144, 131072, 65536, 32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]flag_meanings :land coastline fresh_inland_water tidal_region bright straylight_risk invalid cosmetic duplicated sun_glint_risk dubious saturated_Oa01 saturated_Oa02 saturated_Oa03 saturated_Oa04 saturated_Oa05 saturated_Oa06 saturated_Oa07 saturated_Oa08 saturated_Oa09 saturated_Oa10 saturated_Oa11 saturated_Oa12 saturated_Oa13 saturated_Oa14 saturated_Oa15 saturated_Oa16 saturated_Oa17 saturated_Oa18 saturated_Oa19 saturated_Oa20 saturated_Oa21long_name :Classification and quality flagsgrid_mapping :spatial_ref  Array   Chunk   Bytes   24.30 MiB   16.00 MiB   Shape   (2177, 2926)   (2048, 2048)   Dask graph   4 chunks in 11 graph layers   Data type   uint32 numpy.ndarray  2926 2177 </li><li>rtoa_3(lat, lon)float32dask.array&lt;chunksize=(2048, 2048), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :2.0units :1wavelength :442.5grid_mapping :spatial_ref  Array   Chunk   Bytes   24.30 MiB   16.00 MiB   Shape   (2177, 2926)   (2048, 2048)   Dask graph   4 chunks in 11 graph layers   Data type   float32 numpy.ndarray  2926 2177 </li><li>rtoa_6(lat, lon)float32dask.array&lt;chunksize=(2048, 2048), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :5.0units :1wavelength :560.0grid_mapping :spatial_ref  Array   Chunk   Bytes   24.30 MiB   16.00 MiB   Shape   (2177, 2926)   (2048, 2048)   Dask graph   4 chunks in 11 graph layers   Data type   float32 numpy.ndarray  2926 2177 </li><li>rtoa_8(lat, lon)float32dask.array&lt;chunksize=(2048, 2048), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :7.0units :1wavelength :665.0grid_mapping :spatial_ref  Array   Chunk   Bytes   24.30 MiB   16.00 MiB   Shape   (2177, 2926)   (2048, 2048)   Dask graph   4 chunks in 11 graph layers   Data type   float32 numpy.ndarray  2926 2177 </li></ul></li><li>Indexes: (2)<ul><li>lonPandasIndex<pre>PandasIndex(Index([         12.694301, 12.696800999999999,          12.699301,\n                12.701801,          12.704301, 12.706800999999999,\n                12.709301,          12.711801, 12.714300999999999,\n                12.716801,\n       ...\n                19.984301,          19.986801, 19.989300999999998,\n                19.991801,          19.994301, 19.996800999999998,\n                19.999301,          20.001801, 20.004300999999998,\n                20.006801],\n      dtype='float64', name='lon', length=2926))</pre></li><li>latPandasIndex<pre>PandasIndex(Index([          60.64018,           60.63768,           60.63518,\n                 60.63268,           60.63018,           60.62768,\n                 60.62518,           60.62268,           60.62018,\n                 60.61768,\n       ...\n                 55.22268,           55.22018, 55.217679999999994,\n                 55.21518,           55.21268, 55.210179999999994,\n       55.207679999999996,           55.20518, 55.202679999999994,\n       55.200179999999996],\n      dtype='float64', name='lat', length=2177))</pre></li></ul></li><li>Attributes: (4)Conventions :CF-1.4product_type :C2RCC_OLCIstart_date :04-JUL-2018 09:21:55.677316stop_date :04-JUL-2018 09:23:18.811790</li></ul> In\u00a0[7]: Copied! <pre>%%time\ntarget_ds.rtoa_8.plot(cmap=\"gray\", vmax=0.2)\n</pre> %%time target_ds.rtoa_8.plot(cmap=\"gray\", vmax=0.2) <pre>CPU times: user 1.5 s, sys: 167 ms, total: 1.67 s\nWall time: 1.31 s\n</pre> Out[7]: <pre>&lt;matplotlib.collections.QuadMesh at 0x760b1009e710&gt;</pre> <p>We can also apply a different interpolation method, as shown in the next cell.</p> In\u00a0[8]: Copied! <pre>%%time\ntarget_ds_bilin = rectify_dataset(source_ds, interp_methods=\"bilinear\")\ntarget_ds_bilin\n</pre> %%time target_ds_bilin = rectify_dataset(source_ds, interp_methods=\"bilinear\") target_ds_bilin <pre>CPU times: user 2.16 s, sys: 126 ms, total: 2.29 s\nWall time: 1.29 s\n</pre> Out[8]: <pre>&lt;xarray.Dataset&gt; Size: 102MB\nDimensions:        (lon: 2926, lat: 2177)\nCoordinates:\n    spatial_ref    int64 8B 0\n  * lon            (lon) float64 23kB 12.69 12.7 12.7 12.7 ... 20.0 20.0 20.01\n  * lat            (lat) float64 17kB 60.64 60.64 60.64 ... 55.21 55.2 55.2\nData variables:\n    quality_flags  (lat, lon) uint32 25MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    rtoa_3         (lat, lon) float32 25MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    rtoa_6         (lat, lon) float32 25MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\n    rtoa_8         (lat, lon) float32 25MB dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;\nAttributes:\n    Conventions:   CF-1.4\n    product_type:  C2RCC_OLCI\n    start_date:    04-JUL-2018 09:21:55.677316\n    stop_date:     04-JUL-2018 09:23:18.811790</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>lon: 2926</li><li>lat: 2177</li></ul></li><li>Coordinates: (3)<ul><li>spatial_ref()int640crs_wkt :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensemblegrid_mapping_name :latitude_longitude<pre>array(0)</pre></li><li>lon(lon)float6412.69 12.7 12.7 ... 20.0 20.0 20.01long_name :longitude coordinatestandard_name :longitudeunits :degrees_eastbounds :lon_bnds<pre>array([12.694301, 12.696801, 12.699301, ..., 20.001801, 20.004301, 20.006801],\n      shape=(2926,))</pre></li><li>lat(lat)float6460.64 60.64 60.64 ... 55.2 55.2long_name :latitude coordinatestandard_name :latitudeunits :degrees_northbounds :lat_bnds<pre>array([60.64018, 60.63768, 60.63518, ..., 55.20518, 55.20268, 55.20018],\n      shape=(2177,))</pre></li></ul></li><li>Data variables: (4)<ul><li>quality_flags(lat, lon)uint32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;flag_coding_name :quality_flagsflag_descriptions :flag_masks :[-2147483648, 1073741824, 536870912, 268435456, 134217728, 67108864, 33554432, 16777216, 8388608, 4194304, 2097152, 1048576, 524288, 262144, 131072, 65536, 32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]flag_meanings :land coastline fresh_inland_water tidal_region bright straylight_risk invalid cosmetic duplicated sun_glint_risk dubious saturated_Oa01 saturated_Oa02 saturated_Oa03 saturated_Oa04 saturated_Oa05 saturated_Oa06 saturated_Oa07 saturated_Oa08 saturated_Oa09 saturated_Oa10 saturated_Oa11 saturated_Oa12 saturated_Oa13 saturated_Oa14 saturated_Oa15 saturated_Oa16 saturated_Oa17 saturated_Oa18 saturated_Oa19 saturated_Oa20 saturated_Oa21long_name :Classification and quality flagsgrid_mapping :spatial_ref  Array   Chunk   Bytes   24.30 MiB   1.00 MiB   Shape   (2177, 2926)   (512, 512)   Dask graph   30 chunks in 40 graph layers   Data type   uint32 numpy.ndarray  2926 2177 </li><li>rtoa_3(lat, lon)float32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :2.0units :1wavelength :442.5grid_mapping :spatial_ref  Array   Chunk   Bytes   24.30 MiB   1.00 MiB   Shape   (2177, 2926)   (512, 512)   Dask graph   30 chunks in 40 graph layers   Data type   float32 numpy.ndarray  2926 2177 </li><li>rtoa_6(lat, lon)float32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :5.0units :1wavelength :560.0grid_mapping :spatial_ref  Array   Chunk   Bytes   24.30 MiB   1.00 MiB   Shape   (2177, 2926)   (512, 512)   Dask graph   30 chunks in 40 graph layers   Data type   float32 numpy.ndarray  2926 2177 </li><li>rtoa_8(lat, lon)float32dask.array&lt;chunksize=(512, 512), meta=np.ndarray&gt;bandwidth :10.0long_name :Top-of-atmosphere reflectancespectral_band_index :7.0units :1wavelength :665.0grid_mapping :spatial_ref  Array   Chunk   Bytes   24.30 MiB   1.00 MiB   Shape   (2177, 2926)   (512, 512)   Dask graph   30 chunks in 40 graph layers   Data type   float32 numpy.ndarray  2926 2177 </li></ul></li><li>Indexes: (2)<ul><li>lonPandasIndex<pre>PandasIndex(Index([         12.694301, 12.696800999999999,          12.699301,\n                12.701801,          12.704301, 12.706800999999999,\n                12.709301,          12.711801, 12.714300999999999,\n                12.716801,\n       ...\n                19.984301,          19.986801, 19.989300999999998,\n                19.991801,          19.994301, 19.996800999999998,\n                19.999301,          20.001801, 20.004300999999998,\n                20.006801],\n      dtype='float64', name='lon', length=2926))</pre></li><li>latPandasIndex<pre>PandasIndex(Index([          60.64018,           60.63768,           60.63518,\n                 60.63268,           60.63018,           60.62768,\n                 60.62518,           60.62268,           60.62018,\n                 60.61768,\n       ...\n                 55.22268,           55.22018, 55.217679999999994,\n                 55.21518,           55.21268, 55.210179999999994,\n       55.207679999999996,           55.20518, 55.202679999999994,\n       55.200179999999996],\n      dtype='float64', name='lat', length=2177))</pre></li></ul></li><li>Attributes: (4)Conventions :CF-1.4product_type :C2RCC_OLCIstart_date :04-JUL-2018 09:21:55.677316stop_date :04-JUL-2018 09:23:18.811790</li></ul> In\u00a0[9]: Copied! <pre>%%time\ntarget_ds_bilin.rtoa_8.plot(cmap=\"gray\", vmax=0.2)\n</pre> %%time target_ds_bilin.rtoa_8.plot(cmap=\"gray\", vmax=0.2) <pre>CPU times: user 3.04 s, sys: 177 ms, total: 3.22 s\nWall time: 1.48 s\n</pre> Out[9]: <pre>&lt;matplotlib.collections.QuadMesh at 0x760b084547d0&gt;</pre> <p>Next, we visualize the difference between bilinear and nearest-neighbor interpolation.</p> In\u00a0[10]: Copied! <pre>(target_ds_bilin.rtoa_8 - target_ds.rtoa_8).plot(vmin=-0.02, vmax=+0.02, cmap=\"RdBu\")\n</pre> (target_ds_bilin.rtoa_8 - target_ds.rtoa_8).plot(vmin=-0.02, vmax=+0.02, cmap=\"RdBu\") Out[10]: <pre>&lt;matplotlib.collections.QuadMesh at 0x760b10212850&gt;</pre>"},{"location":"examples/rectify_sentinel3/#rectification-to-a-sentinel-3-olci-scene","title":"Rectification to a Sentinel-3 OLCI scene\u00b6","text":"<p>In this notebook, we apply the rectification algorithm to a Setninel-3 OLCI Level-1b scene. The Sentinel-3 OLCI Level-1b product comes with 2D coordinates \u2013 irregular grids where each pixel has its own pair of x/y orlat/lon coordinates. We will there rectify the dataset to a regular grid.</p>"},{"location":"examples/resample_in_space_large_example_reproject_dataset/","title":"Reproject the ESA-CCI land cover map for Europe","text":"In\u00a0[1]: Copied! <pre>from xcube.core.store import new_data_store\nfrom xcube_resampling.spatial import resample_in_space\nfrom xcube_resampling.gridmapping import GridMapping\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nimport pyproj\nimport numpy as np\n</pre> from xcube.core.store import new_data_store from xcube_resampling.spatial import resample_in_space from xcube_resampling.gridmapping import GridMapping from datetime import datetime import matplotlib.pyplot as plt import pyproj import numpy as np <p>We use the ESA CCI Land Cover map available from the DeepESDL public S3 bucket. In the following cell, we access the multi-resolution dataset <code>\"LC-1x2025x2025-2.0.0.levels\"</code> and select the base level, which corresponds to the original spatial resolution of approximately 300 meters.</p> In\u00a0[2]: Copied! <pre>%%time\nstore = new_data_store(\"s3\", root=\"deep-esdl-public\")\nmlds_lc = store.open_data(\"LC-1x2025x2025-2.0.0.levels\")\nds = mlds_lc.base_dataset\nds_time_slice = ds.sel(time=datetime(2022, 1, 1))\nds\n</pre> %%time store = new_data_store(\"s3\", root=\"deep-esdl-public\") mlds_lc = store.open_data(\"LC-1x2025x2025-2.0.0.levels\") ds = mlds_lc.base_dataset ds_time_slice = ds.sel(time=datetime(2022, 1, 1)) ds <pre>CPU times: user 226 ms, sys: 33.7 ms, total: 260 ms\nWall time: 1.01 s\n</pre> Out[2]: <pre>&lt;xarray.Dataset&gt; Size: 3TB\nDimensions:              (time: 31, lat: 64800, lon: 129600, bounds: 2)\nCoordinates:\n  * lat                  (lat) float64 518kB 90.0 90.0 89.99 ... -90.0 -90.0\n  * lon                  (lon) float64 1MB -180.0 -180.0 -180.0 ... 180.0 180.0\n  * time                 (time) datetime64[ns] 248B 1992-01-01 ... 2022-01-01\nDimensions without coordinates: bounds\nData variables:\n    change_count         (time, lat, lon) uint8 260GB dask.array&lt;chunksize=(1, 2025, 2025), meta=np.ndarray&gt;\n    crs                  int32 4B ...\n    current_pixel_state  (time, lat, lon) float32 1TB dask.array&lt;chunksize=(1, 2025, 2025), meta=np.ndarray&gt;\n    lat_bounds           (lat, bounds) float64 1MB dask.array&lt;chunksize=(2025, 2), meta=np.ndarray&gt;\n    lccs_class           (time, lat, lon) uint8 260GB dask.array&lt;chunksize=(1, 2025, 2025), meta=np.ndarray&gt;\n    lon_bounds           (lon, bounds) float64 2MB dask.array&lt;chunksize=(2025, 2), meta=np.ndarray&gt;\n    observation_count    (time, lat, lon) uint16 521GB dask.array&lt;chunksize=(1, 2025, 2025), meta=np.ndarray&gt;\n    processed_flag       (time, lat, lon) float32 1TB dask.array&lt;chunksize=(1, 2025, 2025), meta=np.ndarray&gt;\n    time_bounds          (time, bounds) datetime64[ns] 496B dask.array&lt;chunksize=(1, 2), meta=np.ndarray&gt;\nAttributes: (12/38)\n    Conventions:                CF-1.6\n    TileSize:                   2025:2025\n    cdm_data_type:              grid\n    comment:                    \n    contact:                    https://www.ecmwf.int/en/about/contact-us/get...\n    creation_date:              20181130T095451Z\n    ...                         ...\n    time_coverage_end:          19921231\n    time_coverage_resolution:   P1Y\n    time_coverage_start:        19920101\n    title:                      Land Cover Map of ESA CCI brokered by CDS\n    tracking_id:                61b96fd7-42c3-4374-9de1-0dc3b0bcae2a\n    type:                       ESACCI-LC-L4-LCCS-Map-300m-P1Y</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 31</li><li>lat: 64800</li><li>lon: 129600</li><li>bounds: 2</li></ul></li><li>Coordinates: (3)<ul><li>lat(lat)float6490.0 90.0 89.99 ... -90.0 -90.0axis :Ybounds :lat_boundslong_name :latitudestandard_name :latitudeunits :degrees_northvalid_max :90.0valid_min :-90.0<pre>array([ 89.998611,  89.995833,  89.993056, ..., -89.993056, -89.995833,\n       -89.998611], shape=(64800,))</pre></li><li>lon(lon)float64-180.0 -180.0 ... 180.0 180.0axis :Xbounds :lon_boundslong_name :longitudestandard_name :longitudeunits :degrees_eastvalid_max :180.0valid_min :-180.0<pre>array([-179.998611, -179.995833, -179.993056, ...,  179.993056,  179.995833,\n        179.998611], shape=(129600,))</pre></li><li>time(time)datetime64[ns]1992-01-01 ... 2022-01-01axis :Tbounds :time_boundslong_name :timestandard_name :time<pre>array(['1992-01-01T00:00:00.000000000', '1993-01-01T00:00:00.000000000',\n       '1994-01-01T00:00:00.000000000', '1995-01-01T00:00:00.000000000',\n       '1996-01-01T00:00:00.000000000', '1997-01-01T00:00:00.000000000',\n       '1998-01-01T00:00:00.000000000', '1999-01-01T00:00:00.000000000',\n       '2000-01-01T00:00:00.000000000', '2001-01-01T00:00:00.000000000',\n       '2002-01-01T00:00:00.000000000', '2003-01-01T00:00:00.000000000',\n       '2004-01-01T00:00:00.000000000', '2005-01-01T00:00:00.000000000',\n       '2006-01-01T00:00:00.000000000', '2007-01-01T00:00:00.000000000',\n       '2008-01-01T00:00:00.000000000', '2009-01-01T00:00:00.000000000',\n       '2010-01-01T00:00:00.000000000', '2011-01-01T00:00:00.000000000',\n       '2012-01-01T00:00:00.000000000', '2013-01-01T00:00:00.000000000',\n       '2014-01-01T00:00:00.000000000', '2015-01-01T00:00:00.000000000',\n       '2016-01-01T00:00:00.000000000', '2017-01-01T00:00:00.000000000',\n       '2018-01-01T00:00:00.000000000', '2019-01-01T00:00:00.000000000',\n       '2020-01-01T00:00:00.000000000', '2021-01-01T00:00:00.000000000',\n       '2022-01-01T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li></ul></li><li>Data variables: (9)<ul><li>change_count(time, lat, lon)uint8dask.array&lt;chunksize=(1, 2025, 2025), meta=np.ndarray&gt;long_name :number of class changesvalid_max :100valid_min :0  Array   Chunk   Bytes   242.46 GiB   3.91 MiB   Shape   (31, 64800, 129600)   (1, 2025, 2025)   Dask graph   63488 chunks in 2 graph layers   Data type   uint8 numpy.ndarray  129600 64800 31 </li><li>crs()int32...i2m :0.002777777777778,0.0,0.0,-0.002777777777778,-180.0,90.0wkt :GEOGCS[\"WGS 84\",    DATUM[\"World Geodetic System 1984\",      SPHEROID[\"WGS 84\", 6378137.0, 298.257223563, AUTHORITY[\"EPSG\",\"7030\"]],      AUTHORITY[\"EPSG\",\"6326\"]],    PRIMEM[\"Greenwich\", 0.0, AUTHORITY[\"EPSG\",\"8901\"]],    UNIT[\"degree\", 0.017453292519943295],    AXIS[\"Geodetic longitude\", EAST],    AXIS[\"Geodetic latitude\", NORTH],    AUTHORITY[\"EPSG\",\"4326\"]]<pre>[1 values with dtype=int32]</pre></li><li>current_pixel_state(time, lat, lon)float32dask.array&lt;chunksize=(1, 2025, 2025), meta=np.ndarray&gt;flag_meanings :invalid clear_land clear_water clear_snow_ice cloud cloud_shadowflag_values :[0, 1, 2, 3, 4, 5]long_name :LC pixel type maskstandard_name :land_cover_lccs status_flagvalid_max :5valid_min :0  Array   Chunk   Bytes   0.95 TiB   15.64 MiB   Shape   (31, 64800, 129600)   (1, 2025, 2025)   Dask graph   63488 chunks in 2 graph layers   Data type   float32 numpy.ndarray  129600 64800 31 </li><li>lat_bounds(lat, bounds)float64dask.array&lt;chunksize=(2025, 2), meta=np.ndarray&gt;  Array   Chunk   Bytes   0.99 MiB   31.64 kiB   Shape   (64800, 2)   (2025, 2)   Dask graph   32 chunks in 2 graph layers   Data type   float64 numpy.ndarray  2 64800 </li><li>lccs_class(time, lat, lon)uint8dask.array&lt;chunksize=(1, 2025, 2025), meta=np.ndarray&gt;ancillary_variables :processed_flag current_pixel_state observation_count change_countflag_colors :#ffff64 #ffff64 #ffff00 #aaf0f0 #dcf064 #c8c864 #006400 #00a000 #00a000 #aac800 #003c00 #003c00 #005000 #285000 #285000 #286400 #788200 #8ca000 #be9600 #966400 #966400 #966400 #ffb432 #ffdcd2 #ffebaf #ffc864 #ffd278 #ffebaf #00785a #009678 #00dc82 #c31400 #fff5d7 #dcdcdc #fff5d7 #0046c8 #ffffffflag_meanings :no_data cropland_rainfed cropland_rainfed_herbaceous_cover cropland_rainfed_tree_or_shrub_cover cropland_irrigated mosaic_cropland mosaic_natural_vegetation tree_broadleaved_evergreen_closed_to_open tree_broadleaved_deciduous_closed_to_open tree_broadleaved_deciduous_closed tree_broadleaved_deciduous_open tree_needleleaved_evergreen_closed_to_open tree_needleleaved_evergreen_closed tree_needleleaved_evergreen_open tree_needleleaved_deciduous_closed_to_open tree_needleleaved_deciduous_closed tree_needleleaved_deciduous_open tree_mixed mosaic_tree_and_shrub mosaic_herbaceous shrubland shrubland_evergreen shrubland_deciduous grassland lichens_and_mosses sparse_vegetation sparse_tree sparse_shrub sparse_herbaceous tree_cover_flooded_fresh_or_brakish_water tree_cover_flooded_saline_water shrub_or_herbaceous_cover_flooded urban bare_areas bare_areas_consolidated bare_areas_unconsolidated water snow_and_iceflag_values :[0, 10, 11, 12, 20, 30, 40, 50, 60, 61, 62, 70, 71, 72, 80, 81, 82, 90, 100, 110, 120, 121, 122, 130, 140, 150, 151, 152, 153, 160, 170, 180, 190, 200, 201, 202, 210, 220]long_name :Land cover class defined in LCCSstandard_name :land_cover_lccsvalid_max :220valid_min :1  Array   Chunk   Bytes   242.46 GiB   3.91 MiB   Shape   (31, 64800, 129600)   (1, 2025, 2025)   Dask graph   63488 chunks in 2 graph layers   Data type   uint8 numpy.ndarray  129600 64800 31 </li><li>lon_bounds(lon, bounds)float64dask.array&lt;chunksize=(2025, 2), meta=np.ndarray&gt;  Array   Chunk   Bytes   1.98 MiB   31.64 kiB   Shape   (129600, 2)   (2025, 2)   Dask graph   64 chunks in 2 graph layers   Data type   float64 numpy.ndarray  2 129600 </li><li>observation_count(time, lat, lon)uint16dask.array&lt;chunksize=(1, 2025, 2025), meta=np.ndarray&gt;long_name :number of valid observationsstandard_name :land_cover_lccs number_of_observationsvalid_max :32767valid_min :0  Array   Chunk   Bytes   484.92 GiB   7.82 MiB   Shape   (31, 64800, 129600)   (1, 2025, 2025)   Dask graph   63488 chunks in 2 graph layers   Data type   uint16 numpy.ndarray  129600 64800 31 </li><li>processed_flag(time, lat, lon)float32dask.array&lt;chunksize=(1, 2025, 2025), meta=np.ndarray&gt;flag_meanings :not_processed processedflag_values :[0, 1]long_name :LC map processed area flagstandard_name :land_cover_lccs status_flagvalid_max :1valid_min :0  Array   Chunk   Bytes   0.95 TiB   15.64 MiB   Shape   (31, 64800, 129600)   (1, 2025, 2025)   Dask graph   63488 chunks in 2 graph layers   Data type   float32 numpy.ndarray  129600 64800 31 </li><li>time_bounds(time, bounds)datetime64[ns]dask.array&lt;chunksize=(1, 2), meta=np.ndarray&gt;  Array   Chunk   Bytes   496 B   16 B   Shape   (31, 2)   (1, 2)   Dask graph   31 chunks in 2 graph layers   Data type   datetime64[ns] numpy.ndarray  2 31 </li></ul></li><li>Indexes: (3)<ul><li>latPandasIndex<pre>PandasIndex(Index([ 89.99861111111113,  89.99583333333334,  89.99305555555557,\n        89.99027777777778,  89.98750000000001,  89.98472222222222,\n        89.98194444444445,  89.97916666666669,  89.97638888888889,\n        89.97361111111113,\n       ...\n       -89.97361111111111, -89.97638888888889, -89.97916666666667,\n       -89.98194444444445, -89.98472222222222,           -89.9875,\n       -89.99027777777778, -89.99305555555556, -89.99583333333334,\n       -89.99861111111112],\n      dtype='float64', name='lat', length=64800))</pre></li><li>lonPandasIndex<pre>PandasIndex(Index([ -179.9986111111111, -179.99583333333334, -179.99305555555554,\n       -179.99027777777778,           -179.9875, -179.98472222222222,\n       -179.98194444444445, -179.97916666666666,  -179.9763888888889,\n        -179.9736111111111,\n       ...\n         179.9736111111111,   179.9763888888889,  179.97916666666669,\n        179.98194444444448,  179.98472222222222,            179.9875,\n         179.9902777777778,  179.99305555555554,  179.99583333333334,\n        179.99861111111113],\n      dtype='float64', name='lon', length=129600))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['1992-01-01', '1993-01-01', '1994-01-01', '1995-01-01',\n               '1996-01-01', '1997-01-01', '1998-01-01', '1999-01-01',\n               '2000-01-01', '2001-01-01', '2002-01-01', '2003-01-01',\n               '2004-01-01', '2005-01-01', '2006-01-01', '2007-01-01',\n               '2008-01-01', '2009-01-01', '2010-01-01', '2011-01-01',\n               '2012-01-01', '2013-01-01', '2014-01-01', '2015-01-01',\n               '2016-01-01', '2017-01-01', '2018-01-01', '2019-01-01',\n               '2020-01-01', '2021-01-01', '2022-01-01'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li></ul></li><li>Attributes: (38)Conventions :CF-1.6TileSize :2025:2025cdm_data_type :gridcomment :contact :https://www.ecmwf.int/en/about/contact-us/get-supportcreation_date :20181130T095451Zcreator_email :landcover-cci@uclouvain.becreator_name :UCLouvaincreator_url :http://www.uclouvain.be/geospatial_lat_max :90.0geospatial_lat_min :-90.0geospatial_lat_resolution :0.002778geospatial_lat_units :degrees_northgeospatial_lon_max :180geospatial_lon_min :-180geospatial_lon_resolution :0.002778geospatial_lon_units :degrees_easthistory :amorgos-4,0, lc-sdr-1.0, lc-sr-1.0, lc-classification-1.0,lc-user-tools-3.13,lc-user-tools-4.3id :ESACCI-LC-L4-LCCS-Map-300m-P1Y-1992-v2.0.7cdsinstitution :UCLouvainkeywords :land cover classification,satellite,observationkeywords_vocabulary :NASA Global Change Master Directory (GCMD) Science Keywordslicense :ESA CCI Data Policy: free and open accessnaming_authority :org.esa-cciproduct_version :2.0.7cdsproject :Climate Change Initiative - European Space Agencyreferences :http://www.esa-landcover-cci.org/source :MERIS FR L1B version 5.05, MERIS RR L1B version 8.0, SPOT VGT Pspatial_resolution :300mstandard_name_vocabulary :NetCDF Climate and Forecast (CF) Standard Names version 21summary :This dataset characterizes the land cover of a particular year (see time_coverage). The land cover was derived from the analysis of satellite data time series of the full period.time_coverage_duration :P1Ytime_coverage_end :19921231time_coverage_resolution :P1Ytime_coverage_start :19920101title :Land Cover Map of ESA CCI brokered by CDStracking_id :61b96fd7-42c3-4374-9de1-0dc3b0bcae2atype :ESACCI-LC-L4-LCCS-Map-300m-P1Y</li></ul> <p>We generate a regular grid mapping covering Germany and demonstrate that the new <code>reproject_dataset</code> method produces results very similar to those of the <code>resample_in_space</code> method.</p> <p>As a first step, we create a regular grid mapping using the EPSG:3035 coordinate reference system.</p> In\u00a0[3]: Copied! <pre>%%time\nbbox = [5, 46, 15, 57]\ntarget_crs = \"EPSG:3035\"\nt = pyproj.Transformer.from_crs(\"EPSG:4326\", target_crs, always_xy=True)\ntarget_bbox = t.transform_bounds(*bbox)\nspatial_res = 150\nx_size = int((target_bbox[2] - target_bbox[0]) / spatial_res) + 1\ny_size = int(abs(target_bbox[3] - target_bbox[1]) / spatial_res) + 1\ntarget_gm = GridMapping.regular(\n    size=(x_size, y_size),\n    xy_min=(target_bbox[0] - spatial_res / 2, target_bbox[1] - spatial_res / 2),\n    xy_res=spatial_res,\n    crs=target_crs,\n    tile_size=4000,\n)\n</pre> %%time bbox = [5, 46, 15, 57] target_crs = \"EPSG:3035\" t = pyproj.Transformer.from_crs(\"EPSG:4326\", target_crs, always_xy=True) target_bbox = t.transform_bounds(*bbox) spatial_res = 150 x_size = int((target_bbox[2] - target_bbox[0]) / spatial_res) + 1 y_size = int(abs(target_bbox[3] - target_bbox[1]) / spatial_res) + 1 target_gm = GridMapping.regular(     size=(x_size, y_size),     xy_min=(target_bbox[0] - spatial_res / 2, target_bbox[1] - spatial_res / 2),     xy_res=spatial_res,     crs=target_crs,     tile_size=4000, ) <pre>CPU times: user 33.8 ms, sys: 1.07 ms, total: 34.9 ms\nWall time: 33.8 ms\n</pre> <p>Firstly, we apply the exsisting <code>resample_in_space</code> method, where we clip the source dataset. Otherwise, <code>resampling_in_space</code> would take for ever.</p> In\u00a0[4]: Copied! <pre>%%time\nds_resampling = resample_in_space(ds_time_slice, target_gm=target_gm)\nds_resampling\n</pre> %%time ds_resampling = resample_in_space(ds_time_slice, target_gm=target_gm) ds_resampling <pre>CPU times: user 9.24 s, sys: 205 ms, total: 9.45 s\nWall time: 9.44 s\n</pre> Out[4]: <pre>&lt;xarray.Dataset&gt; Size: 510MB\nDimensions:              (x: 5167, y: 8227, bounds: 2)\nCoordinates:\n    time                 datetime64[ns] 8B 2022-01-01\n    spatial_ref          int64 8B 0\n  * x                    (x) float64 41kB 3.934e+06 3.934e+06 ... 4.708e+06\n  * y                    (y) float64 66kB 3.777e+06 3.777e+06 ... 2.543e+06\nDimensions without coordinates: bounds\nData variables:\n    change_count         (y, x) uint8 43MB dask.array&lt;chunksize=(4000, 4000), meta=np.ndarray&gt;\n    current_pixel_state  (y, x) float32 170MB dask.array&lt;chunksize=(4000, 4000), meta=np.ndarray&gt;\n    lccs_class           (y, x) uint8 43MB dask.array&lt;chunksize=(4000, 4000), meta=np.ndarray&gt;\n    observation_count    (y, x) uint16 85MB dask.array&lt;chunksize=(4000, 4000), meta=np.ndarray&gt;\n    processed_flag       (y, x) float32 170MB dask.array&lt;chunksize=(4000, 4000), meta=np.ndarray&gt;\n    time_bounds          (bounds) datetime64[ns] 16B dask.array&lt;chunksize=(2,), meta=np.ndarray&gt;\nAttributes: (12/38)\n    Conventions:                CF-1.6\n    TileSize:                   2025:2025\n    cdm_data_type:              grid\n    comment:                    \n    contact:                    https://www.ecmwf.int/en/about/contact-us/get...\n    creation_date:              20181130T095451Z\n    ...                         ...\n    time_coverage_end:          19921231\n    time_coverage_resolution:   P1Y\n    time_coverage_start:        19920101\n    title:                      Land Cover Map of ESA CCI brokered by CDS\n    tracking_id:                61b96fd7-42c3-4374-9de1-0dc3b0bcae2a\n    type:                       ESACCI-LC-L4-LCCS-Map-300m-P1Y</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>x: 5167</li><li>y: 8227</li><li>bounds: 2</li></ul></li><li>Coordinates: (4)<ul><li>time()datetime64[ns]2022-01-01axis :Tbounds :time_boundslong_name :timestandard_name :time<pre>array('2022-01-01T00:00:00.000000000', dtype='datetime64[ns]')</pre></li><li>spatial_ref()int640crs_wkt :PROJCRS[\"ETRS89-extended / LAEA Europe\",BASEGEOGCRS[\"ETRS89\",ENSEMBLE[\"European Terrestrial Reference System 1989 ensemble\",MEMBER[\"European Terrestrial Reference Frame 1989\"],MEMBER[\"European Terrestrial Reference Frame 1990\"],MEMBER[\"European Terrestrial Reference Frame 1991\"],MEMBER[\"European Terrestrial Reference Frame 1992\"],MEMBER[\"European Terrestrial Reference Frame 1993\"],MEMBER[\"European Terrestrial Reference Frame 1994\"],MEMBER[\"European Terrestrial Reference Frame 1996\"],MEMBER[\"European Terrestrial Reference Frame 1997\"],MEMBER[\"European Terrestrial Reference Frame 2000\"],MEMBER[\"European Terrestrial Reference Frame 2005\"],MEMBER[\"European Terrestrial Reference Frame 2014\"],MEMBER[\"European Terrestrial Reference Frame 2020\"],ELLIPSOID[\"GRS 1980\",6378137,298.257222101,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[0.1]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4258]],CONVERSION[\"Europe Equal Area 2001\",METHOD[\"Lambert Azimuthal Equal Area\",ID[\"EPSG\",9820]],PARAMETER[\"Latitude of natural origin\",52,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",10,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"False easting\",4321000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",3210000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"northing (Y)\",north,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"easting (X)\",east,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Statistical analysis.\"],AREA[\"Europe - European Union (EU) countries and candidates. Europe - onshore and offshore: Albania; Andorra; Austria; Belgium; Bosnia and Herzegovina; Bulgaria; Croatia; Cyprus; Czechia; Denmark; Estonia; Faroe Islands; Finland; France; Germany; Gibraltar; Greece; Hungary; Iceland; Ireland; Italy; Kosovo; Latvia; Liechtenstein; Lithuania; Luxembourg; Malta; Monaco; Montenegro; Netherlands; North Macedonia; Norway including Svalbard and Jan Mayen; Poland; Portugal including Madeira and Azores; Romania; San Marino; Serbia; Slovakia; Slovenia; Spain including Canary Islands; Sweden; Switzerland; T\u00fcrkiye (Turkey); United Kingdom (UK) including Channel Islands and Isle of Man; Vatican City State.\"],BBOX[24.6,-35.58,84.73,44.83]],ID[\"EPSG\",3035]]semi_major_axis :6378137.0semi_minor_axis :6356752.314140356inverse_flattening :298.257222101reference_ellipsoid_name :GRS 1980longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :ETRS89horizontal_datum_name :European Terrestrial Reference System 1989 ensembleprojected_crs_name :ETRS89-extended / LAEA Europegrid_mapping_name :lambert_azimuthal_equal_arealatitude_of_projection_origin :52.0longitude_of_projection_origin :10.0false_easting :4321000.0false_northing :3210000.0<pre>array(0)</pre></li><li>x(x)float643.934e+06 3.934e+06 ... 4.708e+06<pre>array([3933529., 3933679., 3933829., ..., 4708129., 4708279., 4708429.],\n      shape=(5167,))</pre></li><li>y(y)float643.777e+06 3.777e+06 ... 2.543e+06<pre>array([3776909., 3776759., 3776609., ..., 2543309., 2543159., 2543009.],\n      shape=(8227,))</pre></li></ul></li><li>Data variables: (6)<ul><li>change_count(y, x)uint8dask.array&lt;chunksize=(4000, 4000), meta=np.ndarray&gt;long_name :number of class changesvalid_max :100valid_min :0grid_mapping :spatial_ref  Array   Chunk   Bytes   40.54 MiB   15.26 MiB   Shape   (8227, 5167)   (4000, 4000)   Dask graph   6 chunks in 21 graph layers   Data type   uint8 numpy.ndarray  5167 8227 </li><li>current_pixel_state(y, x)float32dask.array&lt;chunksize=(4000, 4000), meta=np.ndarray&gt;flag_meanings :invalid clear_land clear_water clear_snow_ice cloud cloud_shadowflag_values :[0, 1, 2, 3, 4, 5]long_name :LC pixel type maskstandard_name :land_cover_lccs status_flagvalid_max :5valid_min :0grid_mapping :spatial_ref  Array   Chunk   Bytes   162.16 MiB   61.04 MiB   Shape   (8227, 5167)   (4000, 4000)   Dask graph   6 chunks in 21 graph layers   Data type   float32 numpy.ndarray  5167 8227 </li><li>lccs_class(y, x)uint8dask.array&lt;chunksize=(4000, 4000), meta=np.ndarray&gt;ancillary_variables :processed_flag current_pixel_state observation_count change_countflag_colors :#ffff64 #ffff64 #ffff00 #aaf0f0 #dcf064 #c8c864 #006400 #00a000 #00a000 #aac800 #003c00 #003c00 #005000 #285000 #285000 #286400 #788200 #8ca000 #be9600 #966400 #966400 #966400 #ffb432 #ffdcd2 #ffebaf #ffc864 #ffd278 #ffebaf #00785a #009678 #00dc82 #c31400 #fff5d7 #dcdcdc #fff5d7 #0046c8 #ffffffflag_meanings :no_data cropland_rainfed cropland_rainfed_herbaceous_cover cropland_rainfed_tree_or_shrub_cover cropland_irrigated mosaic_cropland mosaic_natural_vegetation tree_broadleaved_evergreen_closed_to_open tree_broadleaved_deciduous_closed_to_open tree_broadleaved_deciduous_closed tree_broadleaved_deciduous_open tree_needleleaved_evergreen_closed_to_open tree_needleleaved_evergreen_closed tree_needleleaved_evergreen_open tree_needleleaved_deciduous_closed_to_open tree_needleleaved_deciduous_closed tree_needleleaved_deciduous_open tree_mixed mosaic_tree_and_shrub mosaic_herbaceous shrubland shrubland_evergreen shrubland_deciduous grassland lichens_and_mosses sparse_vegetation sparse_tree sparse_shrub sparse_herbaceous tree_cover_flooded_fresh_or_brakish_water tree_cover_flooded_saline_water shrub_or_herbaceous_cover_flooded urban bare_areas bare_areas_consolidated bare_areas_unconsolidated water snow_and_iceflag_values :[0, 10, 11, 12, 20, 30, 40, 50, 60, 61, 62, 70, 71, 72, 80, 81, 82, 90, 100, 110, 120, 121, 122, 130, 140, 150, 151, 152, 153, 160, 170, 180, 190, 200, 201, 202, 210, 220]long_name :Land cover class defined in LCCSstandard_name :land_cover_lccsvalid_max :220valid_min :1grid_mapping :spatial_ref  Array   Chunk   Bytes   40.54 MiB   15.26 MiB   Shape   (8227, 5167)   (4000, 4000)   Dask graph   6 chunks in 21 graph layers   Data type   uint8 numpy.ndarray  5167 8227 </li><li>observation_count(y, x)uint16dask.array&lt;chunksize=(4000, 4000), meta=np.ndarray&gt;long_name :number of valid observationsstandard_name :land_cover_lccs number_of_observationsvalid_max :32767valid_min :0grid_mapping :spatial_ref  Array   Chunk   Bytes   81.08 MiB   30.52 MiB   Shape   (8227, 5167)   (4000, 4000)   Dask graph   6 chunks in 21 graph layers   Data type   uint16 numpy.ndarray  5167 8227 </li><li>processed_flag(y, x)float32dask.array&lt;chunksize=(4000, 4000), meta=np.ndarray&gt;flag_meanings :not_processed processedflag_values :[0, 1]long_name :LC map processed area flagstandard_name :land_cover_lccs status_flagvalid_max :1valid_min :0grid_mapping :spatial_ref  Array   Chunk   Bytes   162.16 MiB   61.04 MiB   Shape   (8227, 5167)   (4000, 4000)   Dask graph   6 chunks in 21 graph layers   Data type   float32 numpy.ndarray  5167 8227 </li><li>time_bounds(bounds)datetime64[ns]dask.array&lt;chunksize=(2,), meta=np.ndarray&gt;grid_mapping :spatial_ref  Array   Chunk   Bytes   16 B   16 B   Shape   (2,)   (2,)   Dask graph   1 chunks in 3 graph layers   Data type   datetime64[ns] numpy.ndarray  2 1 </li></ul></li><li>Indexes: (2)<ul><li>xPandasIndex<pre>PandasIndex(Index([3933529.0, 3933679.0, 3933829.0, 3933979.0, 3934129.0, 3934279.0,\n       3934429.0, 3934579.0, 3934729.0, 3934879.0,\n       ...\n       4707079.0, 4707229.0, 4707379.0, 4707529.0, 4707679.0, 4707829.0,\n       4707979.0, 4708129.0, 4708279.0, 4708429.0],\n      dtype='float64', name='x', length=5167))</pre></li><li>yPandasIndex<pre>PandasIndex(Index([3776909.0, 3776759.0, 3776609.0, 3776459.0, 3776309.0, 3776159.0,\n       3776009.0, 3775859.0, 3775709.0, 3775559.0,\n       ...\n       2544359.0, 2544209.0, 2544059.0, 2543909.0, 2543759.0, 2543609.0,\n       2543459.0, 2543309.0, 2543159.0, 2543009.0],\n      dtype='float64', name='y', length=8227))</pre></li></ul></li><li>Attributes: (38)Conventions :CF-1.6TileSize :2025:2025cdm_data_type :gridcomment :contact :https://www.ecmwf.int/en/about/contact-us/get-supportcreation_date :20181130T095451Zcreator_email :landcover-cci@uclouvain.becreator_name :UCLouvaincreator_url :http://www.uclouvain.be/geospatial_lat_max :90.0geospatial_lat_min :-90.0geospatial_lat_resolution :0.002778geospatial_lat_units :degrees_northgeospatial_lon_max :180geospatial_lon_min :-180geospatial_lon_resolution :0.002778geospatial_lon_units :degrees_easthistory :amorgos-4,0, lc-sdr-1.0, lc-sr-1.0, lc-classification-1.0,lc-user-tools-3.13,lc-user-tools-4.3id :ESACCI-LC-L4-LCCS-Map-300m-P1Y-1992-v2.0.7cdsinstitution :UCLouvainkeywords :land cover classification,satellite,observationkeywords_vocabulary :NASA Global Change Master Directory (GCMD) Science Keywordslicense :ESA CCI Data Policy: free and open accessnaming_authority :org.esa-cciproduct_version :2.0.7cdsproject :Climate Change Initiative - European Space Agencyreferences :http://www.esa-landcover-cci.org/source :MERIS FR L1B version 5.05, MERIS RR L1B version 8.0, SPOT VGT Pspatial_resolution :300mstandard_name_vocabulary :NetCDF Climate and Forecast (CF) Standard Names version 21summary :This dataset characterizes the land cover of a particular year (see time_coverage). The land cover was derived from the analysis of satellite data time series of the full period.time_coverage_duration :P1Ytime_coverage_end :19921231time_coverage_resolution :P1Ytime_coverage_start :19920101title :Land Cover Map of ESA CCI brokered by CDStracking_id :61b96fd7-42c3-4374-9de1-0dc3b0bcae2atype :ESACCI-LC-L4-LCCS-Map-300m-P1Y</li></ul> In\u00a0[5]: Copied! <pre>%%time\nds_resampling.lccs_class[::5, ::5].plot()\n</pre> %%time ds_resampling.lccs_class[::5, ::5].plot() <pre>CPU times: user 6.74 s, sys: 805 ms, total: 7.55 s\nWall time: 3.48 s\n</pre> Out[5]: <pre>&lt;matplotlib.collections.QuadMesh at 0x758de04f27b0&gt;</pre> <p>The <code>reproject_dataset</code> method can handle source datasets of any size. It automatically selects the overlapping portions of the source dataset that intersect with the target grid mapping.</p> <p>If the extent of the source dataset is too small and the target grid mapping extends beyond its boundaries, padding with a fill value is required. This fill value can either be provided by the user or is determined by the data type of the data array, as described in the docstring of the <code>reproject_dataset</code> method.</p> In\u00a0[6]: Copied! <pre>%%time\nds = ds.sel(time=slice(datetime(2018, 1, 1), datetime(2022, 1, 1)))\nds = ds[[\"lccs_class\"]]\nds\n</pre> %%time ds = ds.sel(time=slice(datetime(2018, 1, 1), datetime(2022, 1, 1))) ds = ds[[\"lccs_class\"]] ds <pre>CPU times: user 36.2 ms, sys: 8.95 ms, total: 45.1 ms\nWall time: 44.9 ms\n</pre> Out[6]: <pre>&lt;xarray.Dataset&gt; Size: 42GB\nDimensions:     (time: 5, lat: 64800, lon: 129600)\nCoordinates:\n  * lat         (lat) float64 518kB 90.0 90.0 89.99 89.99 ... -89.99 -90.0 -90.0\n  * lon         (lon) float64 1MB -180.0 -180.0 -180.0 ... 180.0 180.0 180.0\n  * time        (time) datetime64[ns] 40B 2018-01-01 2019-01-01 ... 2022-01-01\nData variables:\n    lccs_class  (time, lat, lon) uint8 42GB dask.array&lt;chunksize=(1, 2025, 2025), meta=np.ndarray&gt;\nAttributes: (12/38)\n    Conventions:                CF-1.6\n    TileSize:                   2025:2025\n    cdm_data_type:              grid\n    comment:                    \n    contact:                    https://www.ecmwf.int/en/about/contact-us/get...\n    creation_date:              20181130T095451Z\n    ...                         ...\n    time_coverage_end:          19921231\n    time_coverage_resolution:   P1Y\n    time_coverage_start:        19920101\n    title:                      Land Cover Map of ESA CCI brokered by CDS\n    tracking_id:                61b96fd7-42c3-4374-9de1-0dc3b0bcae2a\n    type:                       ESACCI-LC-L4-LCCS-Map-300m-P1Y</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 5</li><li>lat: 64800</li><li>lon: 129600</li></ul></li><li>Coordinates: (3)<ul><li>lat(lat)float6490.0 90.0 89.99 ... -90.0 -90.0axis :Ybounds :lat_boundslong_name :latitudestandard_name :latitudeunits :degrees_northvalid_max :90.0valid_min :-90.0<pre>array([ 89.998611,  89.995833,  89.993056, ..., -89.993056, -89.995833,\n       -89.998611], shape=(64800,))</pre></li><li>lon(lon)float64-180.0 -180.0 ... 180.0 180.0axis :Xbounds :lon_boundslong_name :longitudestandard_name :longitudeunits :degrees_eastvalid_max :180.0valid_min :-180.0<pre>array([-179.998611, -179.995833, -179.993056, ...,  179.993056,  179.995833,\n        179.998611], shape=(129600,))</pre></li><li>time(time)datetime64[ns]2018-01-01 ... 2022-01-01axis :Tbounds :time_boundslong_name :timestandard_name :time<pre>array(['2018-01-01T00:00:00.000000000', '2019-01-01T00:00:00.000000000',\n       '2020-01-01T00:00:00.000000000', '2021-01-01T00:00:00.000000000',\n       '2022-01-01T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li></ul></li><li>Data variables: (1)<ul><li>lccs_class(time, lat, lon)uint8dask.array&lt;chunksize=(1, 2025, 2025), meta=np.ndarray&gt;ancillary_variables :processed_flag current_pixel_state observation_count change_countflag_colors :#ffff64 #ffff64 #ffff00 #aaf0f0 #dcf064 #c8c864 #006400 #00a000 #00a000 #aac800 #003c00 #003c00 #005000 #285000 #285000 #286400 #788200 #8ca000 #be9600 #966400 #966400 #966400 #ffb432 #ffdcd2 #ffebaf #ffc864 #ffd278 #ffebaf #00785a #009678 #00dc82 #c31400 #fff5d7 #dcdcdc #fff5d7 #0046c8 #ffffffflag_meanings :no_data cropland_rainfed cropland_rainfed_herbaceous_cover cropland_rainfed_tree_or_shrub_cover cropland_irrigated mosaic_cropland mosaic_natural_vegetation tree_broadleaved_evergreen_closed_to_open tree_broadleaved_deciduous_closed_to_open tree_broadleaved_deciduous_closed tree_broadleaved_deciduous_open tree_needleleaved_evergreen_closed_to_open tree_needleleaved_evergreen_closed tree_needleleaved_evergreen_open tree_needleleaved_deciduous_closed_to_open tree_needleleaved_deciduous_closed tree_needleleaved_deciduous_open tree_mixed mosaic_tree_and_shrub mosaic_herbaceous shrubland shrubland_evergreen shrubland_deciduous grassland lichens_and_mosses sparse_vegetation sparse_tree sparse_shrub sparse_herbaceous tree_cover_flooded_fresh_or_brakish_water tree_cover_flooded_saline_water shrub_or_herbaceous_cover_flooded urban bare_areas bare_areas_consolidated bare_areas_unconsolidated water snow_and_iceflag_values :[0, 10, 11, 12, 20, 30, 40, 50, 60, 61, 62, 70, 71, 72, 80, 81, 82, 90, 100, 110, 120, 121, 122, 130, 140, 150, 151, 152, 153, 160, 170, 180, 190, 200, 201, 202, 210, 220]long_name :Land cover class defined in LCCSstandard_name :land_cover_lccsvalid_max :220valid_min :1  Array   Chunk   Bytes   39.11 GiB   3.91 MiB   Shape   (5, 64800, 129600)   (1, 2025, 2025)   Dask graph   10240 chunks in 3 graph layers   Data type   uint8 numpy.ndarray  129600 64800 5 </li></ul></li><li>Indexes: (3)<ul><li>latPandasIndex<pre>PandasIndex(Index([ 89.99861111111113,  89.99583333333334,  89.99305555555557,\n        89.99027777777778,  89.98750000000001,  89.98472222222222,\n        89.98194444444445,  89.97916666666669,  89.97638888888889,\n        89.97361111111113,\n       ...\n       -89.97361111111111, -89.97638888888889, -89.97916666666667,\n       -89.98194444444445, -89.98472222222222,           -89.9875,\n       -89.99027777777778, -89.99305555555556, -89.99583333333334,\n       -89.99861111111112],\n      dtype='float64', name='lat', length=64800))</pre></li><li>lonPandasIndex<pre>PandasIndex(Index([ -179.9986111111111, -179.99583333333334, -179.99305555555554,\n       -179.99027777777778,           -179.9875, -179.98472222222222,\n       -179.98194444444445, -179.97916666666666,  -179.9763888888889,\n        -179.9736111111111,\n       ...\n         179.9736111111111,   179.9763888888889,  179.97916666666669,\n        179.98194444444448,  179.98472222222222,            179.9875,\n         179.9902777777778,  179.99305555555554,  179.99583333333334,\n        179.99861111111113],\n      dtype='float64', name='lon', length=129600))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2018-01-01', '2019-01-01', '2020-01-01', '2021-01-01',\n               '2022-01-01'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li></ul></li><li>Attributes: (38)Conventions :CF-1.6TileSize :2025:2025cdm_data_type :gridcomment :contact :https://www.ecmwf.int/en/about/contact-us/get-supportcreation_date :20181130T095451Zcreator_email :landcover-cci@uclouvain.becreator_name :UCLouvaincreator_url :http://www.uclouvain.be/geospatial_lat_max :90.0geospatial_lat_min :-90.0geospatial_lat_resolution :0.002778geospatial_lat_units :degrees_northgeospatial_lon_max :180geospatial_lon_min :-180geospatial_lon_resolution :0.002778geospatial_lon_units :degrees_easthistory :amorgos-4,0, lc-sdr-1.0, lc-sr-1.0, lc-classification-1.0,lc-user-tools-3.13,lc-user-tools-4.3id :ESACCI-LC-L4-LCCS-Map-300m-P1Y-1992-v2.0.7cdsinstitution :UCLouvainkeywords :land cover classification,satellite,observationkeywords_vocabulary :NASA Global Change Master Directory (GCMD) Science Keywordslicense :ESA CCI Data Policy: free and open accessnaming_authority :org.esa-cciproduct_version :2.0.7cdsproject :Climate Change Initiative - European Space Agencyreferences :http://www.esa-landcover-cci.org/source :MERIS FR L1B version 5.05, MERIS RR L1B version 8.0, SPOT VGT Pspatial_resolution :300mstandard_name_vocabulary :NetCDF Climate and Forecast (CF) Standard Names version 21summary :This dataset characterizes the land cover of a particular year (see time_coverage). The land cover was derived from the analysis of satellite data time series of the full period.time_coverage_duration :P1Ytime_coverage_end :19921231time_coverage_resolution :P1Ytime_coverage_start :19920101title :Land Cover Map of ESA CCI brokered by CDStracking_id :61b96fd7-42c3-4374-9de1-0dc3b0bcae2atype :ESACCI-LC-L4-LCCS-Map-300m-P1Y</li></ul> In\u00a0[7]: Copied! <pre>%%time\nbbox = [-20, 25, 40, 85]\ntarget_crs = \"EPSG:3035\"\nt = pyproj.Transformer.from_crs(\"EPSG:4326\", target_crs, always_xy=True)\ntarget_bbox = t.transform_bounds(*bbox)\nspatial_res = 300\nx_size = int((target_bbox[2] - target_bbox[0]) / spatial_res) + 1\ny_size = int(abs(target_bbox[3] - target_bbox[1]) / spatial_res) + 1\ntarget_gm = GridMapping.regular(\n    size=(x_size, y_size),\n    xy_min=(target_bbox[0] - spatial_res / 2, target_bbox[1] - spatial_res / 2),\n    xy_res=spatial_res,\n    crs=target_crs,\n    tile_size=4000,\n)\ntarget_gm\n</pre> %%time bbox = [-20, 25, 40, 85] target_crs = \"EPSG:3035\" t = pyproj.Transformer.from_crs(\"EPSG:4326\", target_crs, always_xy=True) target_bbox = t.transform_bounds(*bbox) spatial_res = 300 x_size = int((target_bbox[2] - target_bbox[0]) / spatial_res) + 1 y_size = int(abs(target_bbox[3] - target_bbox[1]) / spatial_res) + 1 target_gm = GridMapping.regular(     size=(x_size, y_size),     xy_min=(target_bbox[0] - spatial_res / 2, target_bbox[1] - spatial_res / 2),     xy_res=spatial_res,     crs=target_crs,     tile_size=4000, ) target_gm <pre>CPU times: user 18.3 ms, sys: 3.03 ms, total: 21.3 ms\nWall time: 20.5 ms\n</pre> Out[7]: <p>class: RegularGridMapping</p> <ul> <li>is_regular: True</li> <li>is_j_axis_up: False</li> <li>is_lon_360: False</li> <li>crs: EPSG:3035</li> <li>xy_res: (300, 300)</li> <li>xy_bbox: (1287527, 239402, 7354427, 6906902)</li> <li>ij_bbox: (0, 0, 20223, 22225)</li> <li>xy_dim_names: ('x', 'y')</li> <li>xy_var_names: ('x', 'y')</li> <li>size: (20223, 22225)</li> <li>tile_size: (4000, 4000)</li> </ul> In\u00a0[8]: Copied! <pre>%%time\nds_reproject = resample_in_space(ds, target_gm=target_gm)\nds_reproject\n</pre> %%time ds_reproject = resample_in_space(ds, target_gm=target_gm) ds_reproject <pre>CPU times: user 13.9 s, sys: 101 ms, total: 14 s\nWall time: 14 s\n</pre> Out[8]: <pre>&lt;xarray.Dataset&gt; Size: 2GB\nDimensions:      (time: 5, x: 20223, y: 22225)\nCoordinates:\n  * time         (time) datetime64[ns] 40B 2018-01-01 2019-01-01 ... 2022-01-01\n    spatial_ref  int64 8B 0\n  * x            (x) float64 162kB 1.288e+06 1.288e+06 ... 7.354e+06 7.354e+06\n  * y            (y) float64 178kB 6.907e+06 6.906e+06 ... 2.399e+05 2.396e+05\nData variables:\n    lccs_class   (time, y, x) uint8 2GB dask.array&lt;chunksize=(1, 4000, 4000), meta=np.ndarray&gt;\nAttributes: (12/38)\n    Conventions:                CF-1.6\n    TileSize:                   2025:2025\n    cdm_data_type:              grid\n    comment:                    \n    contact:                    https://www.ecmwf.int/en/about/contact-us/get...\n    creation_date:              20181130T095451Z\n    ...                         ...\n    time_coverage_end:          19921231\n    time_coverage_resolution:   P1Y\n    time_coverage_start:        19920101\n    title:                      Land Cover Map of ESA CCI brokered by CDS\n    tracking_id:                61b96fd7-42c3-4374-9de1-0dc3b0bcae2a\n    type:                       ESACCI-LC-L4-LCCS-Map-300m-P1Y</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 5</li><li>x: 20223</li><li>y: 22225</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2018-01-01 ... 2022-01-01axis :Tbounds :time_boundslong_name :timestandard_name :time<pre>array(['2018-01-01T00:00:00.000000000', '2019-01-01T00:00:00.000000000',\n       '2020-01-01T00:00:00.000000000', '2021-01-01T00:00:00.000000000',\n       '2022-01-01T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>spatial_ref()int640crs_wkt :PROJCRS[\"ETRS89-extended / LAEA Europe\",BASEGEOGCRS[\"ETRS89\",ENSEMBLE[\"European Terrestrial Reference System 1989 ensemble\",MEMBER[\"European Terrestrial Reference Frame 1989\"],MEMBER[\"European Terrestrial Reference Frame 1990\"],MEMBER[\"European Terrestrial Reference Frame 1991\"],MEMBER[\"European Terrestrial Reference Frame 1992\"],MEMBER[\"European Terrestrial Reference Frame 1993\"],MEMBER[\"European Terrestrial Reference Frame 1994\"],MEMBER[\"European Terrestrial Reference Frame 1996\"],MEMBER[\"European Terrestrial Reference Frame 1997\"],MEMBER[\"European Terrestrial Reference Frame 2000\"],MEMBER[\"European Terrestrial Reference Frame 2005\"],MEMBER[\"European Terrestrial Reference Frame 2014\"],MEMBER[\"European Terrestrial Reference Frame 2020\"],ELLIPSOID[\"GRS 1980\",6378137,298.257222101,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[0.1]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4258]],CONVERSION[\"Europe Equal Area 2001\",METHOD[\"Lambert Azimuthal Equal Area\",ID[\"EPSG\",9820]],PARAMETER[\"Latitude of natural origin\",52,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",10,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"False easting\",4321000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",3210000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"northing (Y)\",north,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"easting (X)\",east,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Statistical analysis.\"],AREA[\"Europe - European Union (EU) countries and candidates. Europe - onshore and offshore: Albania; Andorra; Austria; Belgium; Bosnia and Herzegovina; Bulgaria; Croatia; Cyprus; Czechia; Denmark; Estonia; Faroe Islands; Finland; France; Germany; Gibraltar; Greece; Hungary; Iceland; Ireland; Italy; Kosovo; Latvia; Liechtenstein; Lithuania; Luxembourg; Malta; Monaco; Montenegro; Netherlands; North Macedonia; Norway including Svalbard and Jan Mayen; Poland; Portugal including Madeira and Azores; Romania; San Marino; Serbia; Slovakia; Slovenia; Spain including Canary Islands; Sweden; Switzerland; T\u00fcrkiye (Turkey); United Kingdom (UK) including Channel Islands and Isle of Man; Vatican City State.\"],BBOX[24.6,-35.58,84.73,44.83]],ID[\"EPSG\",3035]]semi_major_axis :6378137.0semi_minor_axis :6356752.314140356inverse_flattening :298.257222101reference_ellipsoid_name :GRS 1980longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :ETRS89horizontal_datum_name :European Terrestrial Reference System 1989 ensembleprojected_crs_name :ETRS89-extended / LAEA Europegrid_mapping_name :lambert_azimuthal_equal_arealatitude_of_projection_origin :52.0longitude_of_projection_origin :10.0false_easting :4321000.0false_northing :3210000.0<pre>array(0)</pre></li><li>x(x)float641.288e+06 1.288e+06 ... 7.354e+06<pre>array([1287677., 1287977., 1288277., ..., 7353677., 7353977., 7354277.],\n      shape=(20223,))</pre></li><li>y(y)float646.907e+06 6.906e+06 ... 2.396e+05<pre>array([6906752., 6906452., 6906152., ...,  240152.,  239852.,  239552.],\n      shape=(22225,))</pre></li></ul></li><li>Data variables: (1)<ul><li>lccs_class(time, y, x)uint8dask.array&lt;chunksize=(1, 4000, 4000), meta=np.ndarray&gt;ancillary_variables :processed_flag current_pixel_state observation_count change_countflag_colors :#ffff64 #ffff64 #ffff00 #aaf0f0 #dcf064 #c8c864 #006400 #00a000 #00a000 #aac800 #003c00 #003c00 #005000 #285000 #285000 #286400 #788200 #8ca000 #be9600 #966400 #966400 #966400 #ffb432 #ffdcd2 #ffebaf #ffc864 #ffd278 #ffebaf #00785a #009678 #00dc82 #c31400 #fff5d7 #dcdcdc #fff5d7 #0046c8 #ffffffflag_meanings :no_data cropland_rainfed cropland_rainfed_herbaceous_cover cropland_rainfed_tree_or_shrub_cover cropland_irrigated mosaic_cropland mosaic_natural_vegetation tree_broadleaved_evergreen_closed_to_open tree_broadleaved_deciduous_closed_to_open tree_broadleaved_deciduous_closed tree_broadleaved_deciduous_open tree_needleleaved_evergreen_closed_to_open tree_needleleaved_evergreen_closed tree_needleleaved_evergreen_open tree_needleleaved_deciduous_closed_to_open tree_needleleaved_deciduous_closed tree_needleleaved_deciduous_open tree_mixed mosaic_tree_and_shrub mosaic_herbaceous shrubland shrubland_evergreen shrubland_deciduous grassland lichens_and_mosses sparse_vegetation sparse_tree sparse_shrub sparse_herbaceous tree_cover_flooded_fresh_or_brakish_water tree_cover_flooded_saline_water shrub_or_herbaceous_cover_flooded urban bare_areas bare_areas_consolidated bare_areas_unconsolidated water snow_and_iceflag_values :[0, 10, 11, 12, 20, 30, 40, 50, 60, 61, 62, 70, 71, 72, 80, 81, 82, 90, 100, 110, 120, 121, 122, 130, 140, 150, 151, 152, 153, 160, 170, 180, 190, 200, 201, 202, 210, 220]long_name :Land cover class defined in LCCSstandard_name :land_cover_lccsvalid_max :220valid_min :1grid_mapping :spatial_ref  Array   Chunk   Bytes   2.09 GiB   15.26 MiB   Shape   (5, 22225, 20223)   (1, 4000, 4000)   Dask graph   180 chunks in 64 graph layers   Data type   uint8 numpy.ndarray  20223 22225 5 </li></ul></li><li>Indexes: (3)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2018-01-01', '2019-01-01', '2020-01-01', '2021-01-01',\n               '2022-01-01'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>xPandasIndex<pre>PandasIndex(Index([1287677.0, 1287977.0, 1288277.0, 1288577.0, 1288877.0, 1289177.0,\n       1289477.0, 1289777.0, 1290077.0, 1290377.0,\n       ...\n       7351577.0, 7351877.0, 7352177.0, 7352477.0, 7352777.0, 7353077.0,\n       7353377.0, 7353677.0, 7353977.0, 7354277.0],\n      dtype='float64', name='x', length=20223))</pre></li><li>yPandasIndex<pre>PandasIndex(Index([6906752.0, 6906452.0, 6906152.0, 6905852.0, 6905552.0, 6905252.0,\n       6904952.0, 6904652.0, 6904352.0, 6904052.0,\n       ...\n        242252.0,  241952.0,  241652.0,  241352.0,  241052.0,  240752.0,\n        240452.0,  240152.0,  239852.0,  239552.0],\n      dtype='float64', name='y', length=22225))</pre></li></ul></li><li>Attributes: (38)Conventions :CF-1.6TileSize :2025:2025cdm_data_type :gridcomment :contact :https://www.ecmwf.int/en/about/contact-us/get-supportcreation_date :20181130T095451Zcreator_email :landcover-cci@uclouvain.becreator_name :UCLouvaincreator_url :http://www.uclouvain.be/geospatial_lat_max :90.0geospatial_lat_min :-90.0geospatial_lat_resolution :0.002778geospatial_lat_units :degrees_northgeospatial_lon_max :180geospatial_lon_min :-180geospatial_lon_resolution :0.002778geospatial_lon_units :degrees_easthistory :amorgos-4,0, lc-sdr-1.0, lc-sr-1.0, lc-classification-1.0,lc-user-tools-3.13,lc-user-tools-4.3id :ESACCI-LC-L4-LCCS-Map-300m-P1Y-1992-v2.0.7cdsinstitution :UCLouvainkeywords :land cover classification,satellite,observationkeywords_vocabulary :NASA Global Change Master Directory (GCMD) Science Keywordslicense :ESA CCI Data Policy: free and open accessnaming_authority :org.esa-cciproduct_version :2.0.7cdsproject :Climate Change Initiative - European Space Agencyreferences :http://www.esa-landcover-cci.org/source :MERIS FR L1B version 5.05, MERIS RR L1B version 8.0, SPOT VGT Pspatial_resolution :300mstandard_name_vocabulary :NetCDF Climate and Forecast (CF) Standard Names version 21summary :This dataset characterizes the land cover of a particular year (see time_coverage). The land cover was derived from the analysis of satellite data time series of the full period.time_coverage_duration :P1Ytime_coverage_end :19921231time_coverage_resolution :P1Ytime_coverage_start :19920101title :Land Cover Map of ESA CCI brokered by CDStracking_id :61b96fd7-42c3-4374-9de1-0dc3b0bcae2atype :ESACCI-LC-L4-LCCS-Map-300m-P1Y</li></ul> In\u00a0[9]: Copied! <pre>%%time\nds_reproject.lccs_class.isel(time=-1)[::20, ::20].plot()\n</pre> %%time ds_reproject.lccs_class.isel(time=-1)[::20, ::20].plot() <pre>CPU times: user 2min 53s, sys: 46.9 s, total: 3min 40s\nWall time: 50.4 s\n</pre> Out[9]: <pre>&lt;matplotlib.collections.QuadMesh at 0x758df9d80050&gt;</pre> In\u00a0[10]: Copied! <pre>%%time\nds_clip = ds.sel(lon=slice(-20, 40), lat=slice(85, 25))\nds_clip_reproject = resample_in_space(ds_clip, target_gm=target_gm)\nds_clip_reproject\n</pre> %%time ds_clip = ds.sel(lon=slice(-20, 40), lat=slice(85, 25)) ds_clip_reproject = resample_in_space(ds_clip, target_gm=target_gm) ds_clip_reproject <pre>CPU times: user 11.9 s, sys: 55.2 ms, total: 12 s\nWall time: 12 s\n</pre> Out[10]: <pre>&lt;xarray.Dataset&gt; Size: 2GB\nDimensions:      (time: 5, x: 20223, y: 22225)\nCoordinates:\n  * time         (time) datetime64[ns] 40B 2018-01-01 2019-01-01 ... 2022-01-01\n    spatial_ref  int64 8B 0\n  * x            (x) float64 162kB 1.288e+06 1.288e+06 ... 7.354e+06 7.354e+06\n  * y            (y) float64 178kB 6.907e+06 6.906e+06 ... 2.399e+05 2.396e+05\nData variables:\n    lccs_class   (time, y, x) uint8 2GB dask.array&lt;chunksize=(1, 4000, 4000), meta=np.ndarray&gt;\nAttributes: (12/38)\n    Conventions:                CF-1.6\n    TileSize:                   2025:2025\n    cdm_data_type:              grid\n    comment:                    \n    contact:                    https://www.ecmwf.int/en/about/contact-us/get...\n    creation_date:              20181130T095451Z\n    ...                         ...\n    time_coverage_end:          19921231\n    time_coverage_resolution:   P1Y\n    time_coverage_start:        19920101\n    title:                      Land Cover Map of ESA CCI brokered by CDS\n    tracking_id:                61b96fd7-42c3-4374-9de1-0dc3b0bcae2a\n    type:                       ESACCI-LC-L4-LCCS-Map-300m-P1Y</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 5</li><li>x: 20223</li><li>y: 22225</li></ul></li><li>Coordinates: (4)<ul><li>time(time)datetime64[ns]2018-01-01 ... 2022-01-01axis :Tbounds :time_boundslong_name :timestandard_name :time<pre>array(['2018-01-01T00:00:00.000000000', '2019-01-01T00:00:00.000000000',\n       '2020-01-01T00:00:00.000000000', '2021-01-01T00:00:00.000000000',\n       '2022-01-01T00:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>spatial_ref()int640crs_wkt :PROJCRS[\"ETRS89-extended / LAEA Europe\",BASEGEOGCRS[\"ETRS89\",ENSEMBLE[\"European Terrestrial Reference System 1989 ensemble\",MEMBER[\"European Terrestrial Reference Frame 1989\"],MEMBER[\"European Terrestrial Reference Frame 1990\"],MEMBER[\"European Terrestrial Reference Frame 1991\"],MEMBER[\"European Terrestrial Reference Frame 1992\"],MEMBER[\"European Terrestrial Reference Frame 1993\"],MEMBER[\"European Terrestrial Reference Frame 1994\"],MEMBER[\"European Terrestrial Reference Frame 1996\"],MEMBER[\"European Terrestrial Reference Frame 1997\"],MEMBER[\"European Terrestrial Reference Frame 2000\"],MEMBER[\"European Terrestrial Reference Frame 2005\"],MEMBER[\"European Terrestrial Reference Frame 2014\"],MEMBER[\"European Terrestrial Reference Frame 2020\"],ELLIPSOID[\"GRS 1980\",6378137,298.257222101,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[0.1]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4258]],CONVERSION[\"Europe Equal Area 2001\",METHOD[\"Lambert Azimuthal Equal Area\",ID[\"EPSG\",9820]],PARAMETER[\"Latitude of natural origin\",52,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",10,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"False easting\",4321000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",3210000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"northing (Y)\",north,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"easting (X)\",east,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Statistical analysis.\"],AREA[\"Europe - European Union (EU) countries and candidates. Europe - onshore and offshore: Albania; Andorra; Austria; Belgium; Bosnia and Herzegovina; Bulgaria; Croatia; Cyprus; Czechia; Denmark; Estonia; Faroe Islands; Finland; France; Germany; Gibraltar; Greece; Hungary; Iceland; Ireland; Italy; Kosovo; Latvia; Liechtenstein; Lithuania; Luxembourg; Malta; Monaco; Montenegro; Netherlands; North Macedonia; Norway including Svalbard and Jan Mayen; Poland; Portugal including Madeira and Azores; Romania; San Marino; Serbia; Slovakia; Slovenia; Spain including Canary Islands; Sweden; Switzerland; T\u00fcrkiye (Turkey); United Kingdom (UK) including Channel Islands and Isle of Man; Vatican City State.\"],BBOX[24.6,-35.58,84.73,44.83]],ID[\"EPSG\",3035]]semi_major_axis :6378137.0semi_minor_axis :6356752.314140356inverse_flattening :298.257222101reference_ellipsoid_name :GRS 1980longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :ETRS89horizontal_datum_name :European Terrestrial Reference System 1989 ensembleprojected_crs_name :ETRS89-extended / LAEA Europegrid_mapping_name :lambert_azimuthal_equal_arealatitude_of_projection_origin :52.0longitude_of_projection_origin :10.0false_easting :4321000.0false_northing :3210000.0<pre>array(0)</pre></li><li>x(x)float641.288e+06 1.288e+06 ... 7.354e+06<pre>array([1287677., 1287977., 1288277., ..., 7353677., 7353977., 7354277.],\n      shape=(20223,))</pre></li><li>y(y)float646.907e+06 6.906e+06 ... 2.396e+05<pre>array([6906752., 6906452., 6906152., ...,  240152.,  239852.,  239552.],\n      shape=(22225,))</pre></li></ul></li><li>Data variables: (1)<ul><li>lccs_class(time, y, x)uint8dask.array&lt;chunksize=(1, 4000, 4000), meta=np.ndarray&gt;ancillary_variables :processed_flag current_pixel_state observation_count change_countflag_colors :#ffff64 #ffff64 #ffff00 #aaf0f0 #dcf064 #c8c864 #006400 #00a000 #00a000 #aac800 #003c00 #003c00 #005000 #285000 #285000 #286400 #788200 #8ca000 #be9600 #966400 #966400 #966400 #ffb432 #ffdcd2 #ffebaf #ffc864 #ffd278 #ffebaf #00785a #009678 #00dc82 #c31400 #fff5d7 #dcdcdc #fff5d7 #0046c8 #ffffffflag_meanings :no_data cropland_rainfed cropland_rainfed_herbaceous_cover cropland_rainfed_tree_or_shrub_cover cropland_irrigated mosaic_cropland mosaic_natural_vegetation tree_broadleaved_evergreen_closed_to_open tree_broadleaved_deciduous_closed_to_open tree_broadleaved_deciduous_closed tree_broadleaved_deciduous_open tree_needleleaved_evergreen_closed_to_open tree_needleleaved_evergreen_closed tree_needleleaved_evergreen_open tree_needleleaved_deciduous_closed_to_open tree_needleleaved_deciduous_closed tree_needleleaved_deciduous_open tree_mixed mosaic_tree_and_shrub mosaic_herbaceous shrubland shrubland_evergreen shrubland_deciduous grassland lichens_and_mosses sparse_vegetation sparse_tree sparse_shrub sparse_herbaceous tree_cover_flooded_fresh_or_brakish_water tree_cover_flooded_saline_water shrub_or_herbaceous_cover_flooded urban bare_areas bare_areas_consolidated bare_areas_unconsolidated water snow_and_iceflag_values :[0, 10, 11, 12, 20, 30, 40, 50, 60, 61, 62, 70, 71, 72, 80, 81, 82, 90, 100, 110, 120, 121, 122, 130, 140, 150, 151, 152, 153, 160, 170, 180, 190, 200, 201, 202, 210, 220]long_name :Land cover class defined in LCCSstandard_name :land_cover_lccsvalid_max :220valid_min :1grid_mapping :spatial_ref  Array   Chunk   Bytes   2.09 GiB   15.26 MiB   Shape   (5, 22225, 20223)   (1, 4000, 4000)   Dask graph   180 chunks in 64 graph layers   Data type   uint8 numpy.ndarray  20223 22225 5 </li></ul></li><li>Indexes: (3)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2018-01-01', '2019-01-01', '2020-01-01', '2021-01-01',\n               '2022-01-01'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>xPandasIndex<pre>PandasIndex(Index([1287677.0, 1287977.0, 1288277.0, 1288577.0, 1288877.0, 1289177.0,\n       1289477.0, 1289777.0, 1290077.0, 1290377.0,\n       ...\n       7351577.0, 7351877.0, 7352177.0, 7352477.0, 7352777.0, 7353077.0,\n       7353377.0, 7353677.0, 7353977.0, 7354277.0],\n      dtype='float64', name='x', length=20223))</pre></li><li>yPandasIndex<pre>PandasIndex(Index([6906752.0, 6906452.0, 6906152.0, 6905852.0, 6905552.0, 6905252.0,\n       6904952.0, 6904652.0, 6904352.0, 6904052.0,\n       ...\n        242252.0,  241952.0,  241652.0,  241352.0,  241052.0,  240752.0,\n        240452.0,  240152.0,  239852.0,  239552.0],\n      dtype='float64', name='y', length=22225))</pre></li></ul></li><li>Attributes: (38)Conventions :CF-1.6TileSize :2025:2025cdm_data_type :gridcomment :contact :https://www.ecmwf.int/en/about/contact-us/get-supportcreation_date :20181130T095451Zcreator_email :landcover-cci@uclouvain.becreator_name :UCLouvaincreator_url :http://www.uclouvain.be/geospatial_lat_max :90.0geospatial_lat_min :-90.0geospatial_lat_resolution :0.002778geospatial_lat_units :degrees_northgeospatial_lon_max :180geospatial_lon_min :-180geospatial_lon_resolution :0.002778geospatial_lon_units :degrees_easthistory :amorgos-4,0, lc-sdr-1.0, lc-sr-1.0, lc-classification-1.0,lc-user-tools-3.13,lc-user-tools-4.3id :ESACCI-LC-L4-LCCS-Map-300m-P1Y-1992-v2.0.7cdsinstitution :UCLouvainkeywords :land cover classification,satellite,observationkeywords_vocabulary :NASA Global Change Master Directory (GCMD) Science Keywordslicense :ESA CCI Data Policy: free and open accessnaming_authority :org.esa-cciproduct_version :2.0.7cdsproject :Climate Change Initiative - European Space Agencyreferences :http://www.esa-landcover-cci.org/source :MERIS FR L1B version 5.05, MERIS RR L1B version 8.0, SPOT VGT Pspatial_resolution :300mstandard_name_vocabulary :NetCDF Climate and Forecast (CF) Standard Names version 21summary :This dataset characterizes the land cover of a particular year (see time_coverage). The land cover was derived from the analysis of satellite data time series of the full period.time_coverage_duration :P1Ytime_coverage_end :19921231time_coverage_resolution :P1Ytime_coverage_start :19920101title :Land Cover Map of ESA CCI brokered by CDStracking_id :61b96fd7-42c3-4374-9de1-0dc3b0bcae2atype :ESACCI-LC-L4-LCCS-Map-300m-P1Y</li></ul> In\u00a0[11]: Copied! <pre>%%time\nds_clip_reproject.lccs_class.isel(time=-1)[::20, ::20].plot()\n</pre> %%time ds_clip_reproject.lccs_class.isel(time=-1)[::20, ::20].plot() <pre>CPU times: user 3min 1s, sys: 56.1 s, total: 3min 57s\nWall time: 27.1 s\n</pre> Out[11]: <pre>&lt;matplotlib.collections.QuadMesh at 0x758d913c6ad0&gt;</pre>"},{"location":"examples/resample_in_space_large_example_reproject_dataset/#reproject-the-esa-cci-land-cover-map-for-europe","title":"Reproject the ESA-CCI land cover map for Europe\u00b6","text":""}]}