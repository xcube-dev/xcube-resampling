{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"xcube-resampling","text":"<p>xcube-resampling contains alogrithms to represent a dataset in another grid-mapping. It  compromises simple resampling via affine tranformation, reprojection and recification  of nonregular grids to regular grids. All these algorithms can be applied to chunked (lazily loaded) datasets, since they are backed by dask. </p>"},{"location":"#license","title":"License","text":"<p><code>xcube-resampling</code> is open source made available under the terms and conditions of the  MIT license.</p>"},{"location":"about/","title":"About the <code>xcube-resampling</code> project","text":""},{"location":"about/#changelog","title":"Changelog","text":"<p>You can find the complete <code>xcube-resampling</code> changelog  here. </p>"},{"location":"about/#reporting","title":"Reporting","text":"<p>If you have suggestions, ideas, feature requests, or if you have identified a malfunction or error, then please  post an issue. </p>"},{"location":"about/#contributions","title":"Contributions","text":"<p>The <code>xcube-resampling</code> project welcomes contributions of any form as long as you respect our  code of conduct and follow our  contribution guide.</p> <p>If you'd like to submit code or documentation changes, we ask you to provide a  pull request (PR)  here.  For code and configuration changes, your PR must be linked to a  corresponding issue. </p>"},{"location":"about/#development","title":"Development","text":"<p>To install the <code>xcube-resampling</code> development environment into an existing Python  environment, do</p> <pre><code>pip install .[dev,doc]\n</code></pre> <p>or create a new environment using <code>conda</code> or <code>mamba</code></p> <pre><code>mamba env create \n</code></pre>"},{"location":"about/#testing-and-coverage","title":"Testing and Coverage","text":"<p><code>xcube-resampling</code> uses pytest for unit-level testing  and code coverage analysis.</p> <pre><code>pytest tests/ --cov=xcube_resampling --cov-report html\n</code></pre>"},{"location":"about/#code-style","title":"Code Style","text":"<p>The <code>xcube-resampling</code> source code is formatted and quality-controlled  using ruff:</p> <pre><code>ruff format\nruff check\n</code></pre>"},{"location":"about/#documentation","title":"Documentation","text":"<p>The <code>xcube-resampling</code> documentation is built using the  mkdocs tool.</p> <p>With repository root as current working directory:</p> <pre><code>pip install .[doc]\n\nmkdocs build\nmkdocs serve\nmkdocs gh-deploy\n</code></pre>"},{"location":"about/#license","title":"License","text":"<p><code>xcube-resampling</code> is open source made available under the terms and conditions of the  MIT license.</p>"},{"location":"api/","title":"Python API","text":""},{"location":"api/#xcube_resampling.spatial.resample_in_space","title":"<code>xcube_resampling.spatial.resample_in_space(source_ds, target_gm=None, source_gm=None, variables=None, interp_methods=None, agg_methods=None, recover_nans=False, fill_values=None, tile_size=None)</code>","text":"<p>Resample the spatial dimensions of a dataset to match a target grid mapping.</p> <p>Depending on the regularity and compatibility of the source and target grid mappings, this function will either rectify, reproject, or affine-transform the spatial dimensions of <code>source_ds</code>.</p> <p>Parameters:</p> Name Type Description Default <code>source_ds</code> <code>Dataset</code> <p>The input xarray.Dataset. Data variables must have dimensions in the following order: optional third dimension followed by the y-dimension (e.g., \"y\" or \"lat\") and the x-dimension (e.g., \"x\" or \"lon\").</p> required <code>target_gm</code> <code>GridMapping | None</code> <p>The target GridMapping to which the dataset should be resampled. Must be regular. If not provided, a default regular grid is derived from <code>source_gm</code> using <code>to_regular(tile_size)</code>.</p> <code>None</code> <code>source_gm</code> <code>GridMapping | None</code> <p>The GridMapping describing the source dataset's spatial layout. If not provided, it is inferred from <code>source_ds</code> using <code>GridMapping.from_dataset(source_ds)</code>.</p> <code>None</code> <code>variables</code> <code>str | Iterable[str] | None</code> <p>A single variable name or iterable of variable names to be resampled. If None, all data variables will be processed.</p> <code>None</code> <code>interp_methods</code> <code>InterpMethods | None</code> <p>Optional interpolation method to be used for upsampling spatial data variables. Can be a single interpolation method for all variables or a dictionary mapping variable names or dtypes to interpolation method. Supported methods include:     - <code>0</code> (nearest neighbor)     - <code>1</code> (linear / bilinear)     - <code>\"nearest\"</code>     - <code>\"triangular\"</code>     - <code>\"bilinear\"</code> The default is <code>0</code> for integer arrays, else <code>1</code>.</p> <code>None</code> <code>agg_methods</code> <code>AggMethods | None</code> <p>Optional aggregation methods for downsampling spatial variables. Can be a single method for all variables or a dictionary mapping variable names or dtypes to methods. Supported methods include:     \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",     \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\". Defaults to \"center\" for integer arrays, else \"mean\".</p> <code>None</code> <code>recover_nans</code> <code>RecoverNans</code> <p>Optional boolean or mapping to enable NaN recovery during upsampling (only applies when interpolation method is not nearest). Can be a single boolean or a dictionary mapping variable names or dtypes to booleans. Defaults to False.</p> <code>False</code> <code>fill_values</code> <code>FillValues | None</code> <p>Optional fill value(s) for areas outside input coverage. Can be a single value or dictionary by variable or type. If not provided, defaults based on data type are used:     - float: NaN     - uint8: 255     - uint16: 65535     - other ints: -1</p> <code>None</code> <code>tile_size</code> <code>int | tuple[int, int] | None</code> <p>Optional tile size used when generating a regular grid from an irregular source grid mapping. Only used if <code>target_gm</code> is not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>A new dataset that has been spatially resampled to match the target grid mapping.</p> Notes <ul> <li>If <code>source_gm</code> is not provided, it is inferred from <code>source_ds</code>.</li> <li>If <code>target_gm</code> is not provided, and the source is irregular, it is   derived from <code>source_gm.to_regular(tile_size=tile_size)</code>.</li> <li>If both grid mappings are regular and approximately equal, the original   dataset is returned unchanged.</li> <li>If the transformation can be represented as an affine mapping, it is   applied directly for performance.</li> <li>If the source is irregular, rectification is applied.</li> <li>Otherwise, a reprojection is performed.</li> <li>See the xcube-resampling documentation   for more details.</li> </ul> Source code in <code>xcube_resampling/spatial.py</code> <pre><code>def resample_in_space(\n    source_ds: xr.Dataset,\n    target_gm: GridMapping | None = None,\n    source_gm: GridMapping | None = None,\n    variables: str | Iterable[str] | None = None,\n    interp_methods: InterpMethods | None = None,\n    agg_methods: AggMethods | None = None,\n    recover_nans: RecoverNans = False,\n    fill_values: FillValues | None = None,\n    tile_size: int | tuple[int, int] | None = None,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Resample the spatial dimensions of a dataset to match a target grid mapping.\n\n    Depending on the regularity and compatibility of the source and target grid\n    mappings, this function will either rectify, reproject, or affine-transform the\n    spatial dimensions of `source_ds`.\n\n    Args:\n        source_ds: The input xarray.Dataset. Data variables must have dimensions\n            in the following order: optional third dimension followed by the\n            y-dimension (e.g., \"y\" or \"lat\") and the x-dimension (e.g., \"x\" or \"lon\").\n        target_gm: The target GridMapping to which the dataset should be resampled.\n            Must be regular. If not provided, a default regular grid is derived\n            from `source_gm` using `to_regular(tile_size)`.\n        source_gm: The GridMapping describing the source dataset's spatial layout.\n            If not provided, it is inferred from `source_ds` using\n            `GridMapping.from_dataset(source_ds)`.\n        variables: A single variable name or iterable of variable names to be\n            resampled. If None, all data variables will be processed.\n        interp_methods: Optional interpolation method to be used for upsampling spatial\n            data variables. Can be a single interpolation method for all variables or a\n            dictionary mapping variable names or dtypes to interpolation method.\n            Supported methods include:\n                - `0` (nearest neighbor)\n                - `1` (linear / bilinear)\n                - `\"nearest\"`\n                - `\"triangular\"`\n                - `\"bilinear\"`\n            The default is `0` for integer arrays, else `1`.\n        agg_methods: Optional aggregation methods for downsampling spatial variables.\n            Can be a single method for all variables or a dictionary mapping variable\n            names or dtypes to methods. Supported methods include:\n                \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",\n                \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\".\n            Defaults to \"center\" for integer arrays, else \"mean\".\n        recover_nans: Optional boolean or mapping to enable NaN recovery during\n            upsampling (only applies when interpolation method is not nearest).\n            Can be a single boolean or a dictionary mapping variable names or dtypes\n            to booleans. Defaults to False.\n        fill_values: Optional fill value(s) for areas outside input coverage.\n            Can be a single value or dictionary by variable or type. If not provided,\n            defaults based on data type are used:\n                - float: NaN\n                - uint8: 255\n                - uint16: 65535\n                - other ints: -1\n        tile_size: Optional tile size used when generating a regular grid from\n            an irregular source grid mapping. Only used if `target_gm` is not provided.\n\n    Returns:\n        A new dataset that has been spatially resampled to match the target grid\n            mapping.\n\n    Notes:\n        - If `source_gm` is not provided, it is inferred from `source_ds`.\n        - If `target_gm` is not provided, and the source is irregular, it is\n          derived from `source_gm.to_regular(tile_size=tile_size)`.\n        - If both grid mappings are regular and approximately equal, the original\n          dataset is returned unchanged.\n        - If the transformation can be represented as an affine mapping, it is\n          applied directly for performance.\n        - If the source is irregular, rectification is applied.\n        - Otherwise, a reprojection is performed.\n        - See the [xcube-resampling documentation](https://xcube-dev.github.io/xcube-resampling/)\n          for more details.\n    \"\"\"\n    if source_gm is None:\n        source_gm = GridMapping.from_dataset(source_ds)\n\n    if not source_gm.is_regular:\n        return rectify_dataset(\n            source_ds,\n            target_gm=target_gm,\n            source_gm=source_gm,\n            variables=variables,\n            interp_methods=interp_methods,\n            agg_methods=agg_methods,\n            recover_nans=recover_nans,\n            fill_values=fill_values,\n            tile_size=tile_size,\n        )\n    else:\n        if target_gm is None:\n            LOG.warning(\n                \"If source grid mapping is regular `target_gm` must be given. \"\n                \"Source dataset is returned.\"\n            )\n            return source_ds\n        GridMapping.assert_regular(target_gm, name=\"target_gm\")\n        if source_gm.is_close(target_gm):\n            return source_ds\n\n        if _can_apply_affine_transform(source_gm, target_gm):\n            return affine_transform_dataset(\n                source_ds,\n                target_gm,\n                source_gm=source_gm,\n                variables=variables,\n                interp_methods=interp_methods,\n                agg_methods=agg_methods,\n                recover_nans=recover_nans,\n                fill_values=fill_values,\n            )\n        else:\n            return reproject_dataset(\n                source_ds,\n                target_gm,\n                source_gm=source_gm,\n                variables=variables,\n                interp_methods=interp_methods,\n                agg_methods=agg_methods,\n                recover_nans=recover_nans,\n                fill_values=fill_values,\n            )\n</code></pre>"},{"location":"api/#xcube_resampling.affine.affine_transform_dataset","title":"<code>xcube_resampling.affine.affine_transform_dataset(source_ds, target_gm, source_gm=None, variables=None, interp_methods=None, agg_methods=None, recover_nans=False, fill_values=None)</code>","text":"<p>Apply an affine transformation to the spatial dimensions of a dataset, transforming it from the source grid mapping to the target grid mapping.</p> <p>Parameters:</p> Name Type Description Default <code>source_ds</code> <code>Dataset</code> <p>The input dataset to be transformed.</p> required <code>target_gm</code> <code>GridMapping</code> <p>The target grid mapping defining the spatial reference and output geometry.</p> required <code>source_gm</code> <code>GridMapping | None</code> <p>The grid mapping of the input dataset. If None, it is inferred from the dataset.</p> <code>None</code> <code>variables</code> <code>str | Iterable[str] | None</code> <p>Optional variable(s) to transform. If None, all variables are used.</p> <code>None</code> <code>interp_methods</code> <code>InterpMethods | None</code> <p>Optional interpolation method to be used for upsampling spatial data variables. Can be a single interpolation method for all variables or a dictionary mapping variable names or dtypes to interpolation method. Supported methods include:     - <code>0</code> (nearest neighbor)     - <code>1</code> (linear / bilinear)     - <code>\"nearest\"</code>     - <code>\"bilinear\"</code> The default is <code>0</code> for integer arrays, else <code>1</code>.</p> <code>None</code> <code>agg_methods</code> <code>AggMethods | None</code> <p>Optional aggregation methods for downsampling spatial variables. Can be a single method for all variables or a dictionary mapping variable names or dtypes to methods. Supported methods include:     \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",     \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\". Defaults to \"center\" for integer arrays, else \"mean\".</p> <code>None</code> <code>recover_nans</code> <code>RecoverNans</code> <p>Optional boolean or mapping to enable NaN recovery during upsampling (only applies when interpolation method is not nearest). Can be a single boolean or a dictionary mapping variable names or dtypes to booleans. Defaults to False.</p> <code>False</code> <code>fill_values</code> <code>FillValues | None</code> <p>Optional fill value(s) for areas outside the input bounds. Can be a single value or a dictionary mapping variable names or dtypes to fill values. If not provided, defaults are:     - float: NaN     - uint8: 255     - uint16: 65535     - other integers: -1</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>A new dataset resampled and aligned to the target grid mapping. Data variables without spatial dimensions are copied to the output. Data variables with only one spatial dimension are ignored.</p> Source code in <code>xcube_resampling/affine.py</code> <pre><code>def affine_transform_dataset(\n    source_ds: xr.Dataset,\n    target_gm: GridMapping,\n    source_gm: GridMapping | None = None,\n    variables: str | Iterable[str] | None = None,\n    interp_methods: InterpMethods | None = None,\n    agg_methods: AggMethods | None = None,\n    recover_nans: RecoverNans = False,\n    fill_values: FillValues | None = None,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Apply an affine transformation to the spatial dimensions of a dataset,\n    transforming it from the source grid mapping to the target grid mapping.\n\n    Args:\n        source_ds: The input dataset to be transformed.\n        target_gm: The target grid mapping defining the spatial reference and\n            output geometry.\n        source_gm: The grid mapping of the input dataset. If None, it is inferred\n            from the dataset.\n        variables: Optional variable(s) to transform. If None, all variables are used.\n        interp_methods: Optional interpolation method to be used for upsampling spatial\n            data variables. Can be a single interpolation method for all variables or a\n            dictionary mapping variable names or dtypes to interpolation method.\n            Supported methods include:\n                - `0` (nearest neighbor)\n                - `1` (linear / bilinear)\n                - `\"nearest\"`\n                - `\"bilinear\"`\n            The default is `0` for integer arrays, else `1`.\n        agg_methods: Optional aggregation methods for downsampling spatial variables.\n            Can be a single method for all variables or a dictionary mapping variable\n            names or dtypes to methods. Supported methods include:\n                \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",\n                \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\".\n            Defaults to \"center\" for integer arrays, else \"mean\".\n        recover_nans: Optional boolean or mapping to enable NaN recovery during\n            upsampling (only applies when interpolation method is not nearest).\n            Can be a single boolean or a dictionary mapping variable names or dtypes\n            to booleans. Defaults to False.\n        fill_values: Optional fill value(s) for areas outside the input bounds.\n            Can be a single value or a dictionary mapping variable names or dtypes\n            to fill values. If not provided, defaults are:\n                - float: NaN\n                - uint8: 255\n                - uint16: 65535\n                - other integers: -1\n\n    Returns:\n        A new dataset resampled and aligned to the target grid mapping.\n            Data variables without spatial dimensions are copied to the output.\n            Data variables with only one spatial dimension are ignored.\n    \"\"\"\n    if source_gm is None:\n        source_gm = GridMapping.from_dataset(source_ds)\n    source_ds = normalize_grid_mapping(source_ds, source_gm)\n\n    assert _can_apply_affine_transform(source_gm, target_gm), (\n        f\"Affine transformation cannot be applied to source CRS \"\n        f\"{source_gm.crs.name!r} and target CRS {target_gm.crs.name!r}\"\n    )\n\n    source_ds = _select_variables(source_ds, variables)\n\n    target_ds = resample_dataset(\n        source_ds,\n        target_gm.ij_transform_to(source_gm),\n        (source_gm.xy_dim_names[1], source_gm.xy_dim_names[0]),\n        target_gm.size,\n        target_gm.tile_size,\n        interp_methods,\n        agg_methods,\n        recover_nans,\n        fill_values,\n    )\n\n    # assign coordinates from target grid-mapping\n    x_name, y_name = target_gm.xy_dim_names\n    coords = {\n        x_name: target_gm.x_coords,\n        y_name: target_gm.y_coords,\n        \"spatial_ref\": source_ds.spatial_ref,\n    }\n    target_ds = target_ds.assign_coords(coords)\n\n    return target_ds\n</code></pre>"},{"location":"api/#xcube_resampling.reproject.reproject_dataset","title":"<code>xcube_resampling.reproject.reproject_dataset(source_ds, target_gm, source_gm=None, variables=None, interp_methods=None, agg_methods=None, recover_nans=False, fill_values=None)</code>","text":"<p>Reproject a dataset from one coordinate reference system (CRS) to another.</p> <p>This function transforms a dataset\u2019s 2D spatial variables to match a new CRS and grid layout defined by <code>target_gm</code>. It handles interpolation, optional downsampling, and fill values for areas outside the input bounds.</p> <p>Parameters:</p> Name Type Description Default <code>source_ds</code> <code>Dataset</code> <p>The input dataset to be reprojected.</p> required <code>target_gm</code> <code>GridMapping</code> <p>The target grid mapping that defines the spatial reference and grid layout in the target CRS.</p> required <code>source_gm</code> <code>GridMapping | None</code> <p>Optional source grid mapping of the input dataset. If not provided, it is inferred from the dataset.</p> <code>None</code> <code>variables</code> <code>str | Iterable[str] | None</code> <p>Optional variable name or list of variable names to reproject. If None, all suitable variables are processed.</p> <code>None</code> <code>interp_methods</code> <code>InterpMethods | None</code> <p>Optional interpolation method to be used for upsampling spatial data variables. Can be a single interpolation method for all variables or a dictionary mapping variable names or dtypes to interpolation method. Supported methods include:     - <code>0</code> (nearest neighbor)     - <code>1</code> (linear / bilinear)     - <code>\"nearest\"</code>     - <code>\"triangular\"</code>     - <code>\"bilinear\"</code> The default is <code>0</code> for integer arrays, else <code>1</code>.</p> <code>None</code> <code>agg_methods</code> <code>AggMethods | None</code> <p>Optional aggregation methods for downsampling spatial variables. Can be a single method for all variables or a dictionary mapping variable names or dtypes to methods. Supported methods include:     \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",     \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\". Defaults to \"center\" for integer arrays, else \"mean\".</p> <code>None</code> <code>recover_nans</code> <code>RecoverNans</code> <p>Optional boolean or mapping to enable NaN recovery during upsampling (only applies when interpolation method is not nearest). Can be a single boolean or a dictionary mapping variable names or dtypes to booleans. Defaults to False.</p> <code>False</code> <code>fill_values</code> <code>FillValues | None</code> <p>Optional fill value(s) to assign outside source coverage. Can be a single value or dictionary by variable or type. If not set, defaults are:     - float: NaN     - uint8: 255     - uint16: 65535     - other integers: -1</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>A new dataset with variables reprojected to the target CRS and grid. Variables without 2D spatial dimensions are copied as-is. 1D spatial coordinate variables are ignored in the output.</p> Source code in <code>xcube_resampling/reproject.py</code> <pre><code>def reproject_dataset(\n    source_ds: xr.Dataset,\n    target_gm: GridMapping,\n    source_gm: GridMapping | None = None,\n    variables: str | Iterable[str] | None = None,\n    interp_methods: InterpMethods | None = None,\n    agg_methods: AggMethods | None = None,\n    recover_nans: RecoverNans = False,\n    fill_values: FillValues | None = None,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Reproject a dataset from one coordinate reference system (CRS) to another.\n\n    This function transforms a dataset\u2019s 2D spatial variables to match a new CRS and\n    grid layout defined by `target_gm`. It handles interpolation, optional\n    downsampling, and fill values for areas outside the input bounds.\n\n    Args:\n        source_ds: The input dataset to be reprojected.\n        target_gm: The target grid mapping that defines the spatial reference and\n            grid layout in the target CRS.\n        source_gm: Optional source grid mapping of the input dataset. If not\n            provided, it is inferred from the dataset.\n        variables: Optional variable name or list of variable names to reproject.\n            If None, all suitable variables are processed.\n        interp_methods: Optional interpolation method to be used for upsampling spatial\n            data variables. Can be a single interpolation method for all variables or a\n            dictionary mapping variable names or dtypes to interpolation method.\n            Supported methods include:\n                - `0` (nearest neighbor)\n                - `1` (linear / bilinear)\n                - `\"nearest\"`\n                - `\"triangular\"`\n                - `\"bilinear\"`\n            The default is `0` for integer arrays, else `1`.\n        agg_methods: Optional aggregation methods for downsampling spatial variables.\n            Can be a single method for all variables or a dictionary mapping variable\n            names or dtypes to methods. Supported methods include:\n                \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",\n                \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\".\n            Defaults to \"center\" for integer arrays, else \"mean\".\n        recover_nans: Optional boolean or mapping to enable NaN recovery during\n            upsampling (only applies when interpolation method is not nearest).\n            Can be a single boolean or a dictionary mapping variable names or dtypes\n            to booleans. Defaults to False.\n        fill_values: Optional fill value(s) to assign outside source coverage.\n            Can be a single value or dictionary by variable or type. If not set,\n            defaults are:\n                - float: NaN\n                - uint8: 255\n                - uint16: 65535\n                - other integers: -1\n\n    Returns:\n        A new dataset with variables reprojected to the target CRS and\n            grid. Variables without 2D spatial dimensions are copied as-is.\n            1D spatial coordinate variables are ignored in the output.\n    \"\"\"\n\n    if source_gm is None:\n        source_gm = GridMapping.from_dataset(source_ds)\n    source_ds = normalize_grid_mapping(source_ds, source_gm)\n\n    source_ds = _select_variables(source_ds, variables)\n\n    transformer = pyproj.Transformer.from_crs(\n        target_gm.crs, source_gm.crs, always_xy=True\n    )\n\n    # If source has higher resolution than target, downscale first, then reproject\n    source_ds, source_gm = _downscale_source_dataset(\n        source_ds,\n        source_gm,\n        target_gm,\n        transformer,\n        interp_methods,\n        agg_methods,\n        recover_nans,\n    )\n\n    # For each bounding box in the target grid mapping:\n    # - determine the indices of the bbox in the source dataset\n    # - extract the corresponding coordinates for each bbox in the source dataset\n    # - compute the pad_width to handle areas requested by target_gm that exceed the\n    #   bounds of source_gm.\n    scr_ij_bboxes, x_coords, y_coords, pad_width = _get_scr_bboxes_indices(\n        transformer, source_gm, target_gm\n    )\n\n    # transform grid points from target grid mapping to source grid mapping\n    source_xx, source_yy = _transform_gridpoints(transformer, target_gm)\n\n    # reproject dataset\n    x_name, y_name = target_gm.xy_dim_names\n    target_coords = target_gm.to_coords()\n    coords = {\n        x_name: target_coords[x_name],\n        y_name: target_coords[y_name],\n        \"spatial_ref\": xr.DataArray(0, attrs=target_gm.crs.to_cf()),\n    }\n    target_ds = xr.Dataset(coords=coords, attrs=source_ds.attrs)\n\n    yx_dims = (source_gm.xy_dim_names[1], source_gm.xy_dim_names[0])\n    for var_name, data_array in source_ds.items():\n        if data_array.dims[-2:] == yx_dims:\n            assert len(data_array.dims) in (\n                2,\n                3,\n            ), f\"Data variable {var_name} has {len(data_array.dims)} dimensions.\"\n\n            target_ds[var_name] = _reproject_data_array(\n                data_array,\n                var_name,\n                source_gm,\n                target_gm,\n                source_xx,\n                source_yy,\n                x_coords,\n                y_coords,\n                scr_ij_bboxes,\n                pad_width,\n                interp_methods,\n                fill_values,\n            )\n        elif yx_dims[0] not in data_array.dims and yx_dims[1] not in data_array.dims:\n            target_ds[var_name] = data_array\n\n    return target_ds\n</code></pre>"},{"location":"api/#xcube_resampling.rectify.rectify_dataset","title":"<code>xcube_resampling.rectify.rectify_dataset(source_ds, target_gm=None, source_gm=None, variables=None, interp_methods=None, agg_methods=None, recover_nans=False, fill_values=None, tile_size=None)</code>","text":"<p>Rectify a dataset with non-regular grid to a regular grid defined by a target grid mapping.</p> <p>This function transforms spatial coordinates to a regular grid while preserving data values. It optionally downsamples high-resolution inputs prior to rectifying.</p> <p>Parameters:</p> Name Type Description Default <code>source_ds</code> <code>Dataset</code> <p>The source dataset with 2D spatial coordinate variables.</p> required <code>target_gm</code> <code>GridMapping | None</code> <p>Optional target grid mapping defining the output regular grid. If not provided, one is derived from the source grid mapping.</p> <code>None</code> <code>source_gm</code> <code>GridMapping | None</code> <p>Optional grid mapping of the source dataset. If not given, it is inferred from the dataset.</p> <code>None</code> <code>variables</code> <code>str | Iterable[str] | None</code> <p>Optional variable(s) to rectify. If None, all eligible variables are processed.</p> <code>None</code> <code>interp_methods</code> <code>InterpMethods | None</code> <p>Optional interpolation method to be used for upsampling spatial data variables. Can be a single interpolation method for all variables or a dictionary mapping variable names or dtypes to interpolation method. Supported methods include:     - <code>0</code> (nearest neighbor)     - <code>1</code> (linear / bilinear)     - <code>\"nearest\"</code>     - <code>\"triangular\"</code>     - <code>\"bilinear\"</code> The default is <code>0</code> for integer arrays, else <code>1</code>.</p> <code>None</code> <code>agg_methods</code> <code>AggMethods | None</code> <p>Optional aggregation methods for downsampling spatial variables. Can be a single method for all variables or a dictionary mapping variable names or dtypes to methods. Supported methods include:     \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",     \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\". Defaults to \"center\" for integer arrays, else \"mean\".</p> <code>None</code> <code>recover_nans</code> <code>RecoverNans</code> <p>Optional boolean or mapping to enable NaN recovery during upsampling (only applies when interpolation method is not nearest). Can be a single boolean or a dictionary mapping variable names or dtypes to booleans. Defaults to False.</p> <code>False</code> <code>fill_values</code> <code>FillValues | None</code> <p>Optional fill value(s) for areas outside input coverage. Can be a single value or dictionary by variable or type. If not provided, defaults based on data type are used:     - float: NaN     - uint8: 255     - uint16: 65535     - other ints: -1</p> <code>None</code> <code>tile_size</code> <code>int | tuple[int, int] | None</code> <p>Optional tile size for inferring a regular grid, if <code>target_gm</code> is not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>A new dataset with spatial variables rectified to a regular grid. Variables not having 2D spatial dimensions are copied as-is. 1D spatial coordinate variables are ignored in the output.</p> Source code in <code>xcube_resampling/rectify.py</code> <pre><code>def rectify_dataset(\n    source_ds: xr.Dataset,\n    target_gm: GridMapping | None = None,\n    source_gm: GridMapping | None = None,\n    variables: str | Iterable[str] | None = None,\n    interp_methods: InterpMethods | None = None,\n    agg_methods: AggMethods | None = None,\n    recover_nans: RecoverNans = False,\n    fill_values: FillValues | None = None,\n    tile_size: int | tuple[int, int] | None = None,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Rectify a dataset with non-regular grid to a regular grid defined by a target\n    grid mapping.\n\n    This function transforms spatial coordinates to a regular grid while preserving\n    data values. It optionally downsamples high-resolution inputs prior to rectifying.\n\n    Args:\n        source_ds: The source dataset with 2D spatial coordinate variables.\n        target_gm: Optional target grid mapping defining the output regular grid.\n            If not provided, one is derived from the source grid mapping.\n        source_gm: Optional grid mapping of the source dataset. If not given, it is\n            inferred from the dataset.\n        variables: Optional variable(s) to rectify. If None, all eligible variables\n            are processed.\n        interp_methods: Optional interpolation method to be used for upsampling spatial\n            data variables. Can be a single interpolation method for all variables or a\n            dictionary mapping variable names or dtypes to interpolation method.\n            Supported methods include:\n                - `0` (nearest neighbor)\n                - `1` (linear / bilinear)\n                - `\"nearest\"`\n                - `\"triangular\"`\n                - `\"bilinear\"`\n            The default is `0` for integer arrays, else `1`.\n        agg_methods: Optional aggregation methods for downsampling spatial variables.\n            Can be a single method for all variables or a dictionary mapping variable\n            names or dtypes to methods. Supported methods include:\n                \"center\", \"count\", \"first\", \"last\", \"max\", \"mean\", \"median\",\n                \"mode\", \"min\", \"prod\", \"std\", \"sum\", and \"var\".\n            Defaults to \"center\" for integer arrays, else \"mean\".\n        recover_nans: Optional boolean or mapping to enable NaN recovery during\n            upsampling (only applies when interpolation method is not nearest).\n            Can be a single boolean or a dictionary mapping variable names or dtypes\n            to booleans. Defaults to False.\n        fill_values: Optional fill value(s) for areas outside input coverage.\n            Can be a single value or dictionary by variable or type. If not provided,\n            defaults based on data type are used:\n                - float: NaN\n                - uint8: 255\n                - uint16: 65535\n                - other ints: -1\n        tile_size: Optional tile size for inferring a regular grid, if `target_gm` is\n            not provided.\n\n    Returns:\n        A new dataset with spatial variables rectified to a regular grid.\n            Variables not having 2D spatial dimensions are copied as-is. 1D spatial\n            coordinate variables are ignored in the output.\n    \"\"\"\n    if source_gm is None:\n        source_gm = GridMapping.from_dataset(source_ds)\n    source_ds = normalize_grid_mapping(source_ds, source_gm)\n\n    if target_gm is None:\n        target_gm = source_gm.to_regular(tile_size=tile_size)\n\n    # transform 2d spatial coordinate of source dataset to target CRS\n    if not _is_equal_crs(source_gm, target_gm):\n        source_ds = _transform_coords(source_ds, source_gm, target_gm)\n        source_gm = GridMapping.from_dataset(source_ds)\n\n    source_ds = _select_variables(source_ds, variables)\n\n    # ToDo: clip dataset\n\n    # If source has higher resolution than target, downscale first, then rectify\n    source_ds, source_gm = _downscale_source_dataset(\n        source_ds,\n        source_gm,\n        target_gm,\n        interp_methods,\n        agg_methods,\n        recover_nans,\n    )\n\n    # calculate source indices in target grid-mapping\n    target_source_ij = _compute_target_source_ij(source_gm, target_gm, UV_DELTA)\n\n    # rectify dataset\n    x_name, y_name = target_gm.xy_dim_names\n    target_coords = target_gm.to_coords()\n    coords = {\n        x_name: target_coords[x_name],\n        y_name: target_coords[y_name],\n        \"spatial_ref\": xr.DataArray(0, attrs=target_gm.crs.to_cf()),\n    }\n    target_ds = xr.Dataset(coords=coords, attrs=source_ds.attrs)\n\n    yx_dims = (source_gm.xy_dim_names[1], source_gm.xy_dim_names[0])\n    for var_name, data_array in source_ds.items():\n        if var_name in target_gm.xy_var_names:\n            continue\n        if data_array.dims[-2:] == yx_dims:\n            assert len(data_array.dims) in (\n                2,\n                3,\n            ), f\"Data variable {var_name} has {len(data_array.dims)} dimensions.\"\n\n            target_ds[var_name] = _rectify_data_array(\n                data_array,\n                var_name,\n                target_gm,\n                target_source_ij,\n                interp_methods,\n                fill_values,\n            )\n\n        elif yx_dims[0] not in data_array.dims and yx_dims[1] not in data_array.dims:\n            target_ds[var_name] = data_array\n\n    return target_ds\n</code></pre>"},{"location":"guide/","title":"User Guide","text":""},{"location":"guide/#user-guide-for-xcube-resampling","title":"User Guide for xcube-resampling","text":"<p>under construction</p>"},{"location":"start/","title":"Getting Started","text":"<p>The <code>xcube-resampling</code> package can be installed into an existing Python environment using</p> <pre><code>pip install xcube-resampling\n</code></pre> <p>or</p> <pre><code>conda install -c conda-forge xcube-resampling\n</code></pre>"}]}